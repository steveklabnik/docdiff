<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Windows version 5.5.12">
<meta charset="utf-8">
<meta name="viewport" content=
"width=device-width, initial-scale=1.0">
<meta name="generator" content="rustdoc">
<meta name="description" content=
"API documentation for the Rust `Unique` struct in crate `std`.">
<meta name="keywords" content="rust, rustlang, rust-lang, Unique">
<title>std::ptr::Unique - Rust</title>
<link rel="stylesheet" type="text/css" href="../../normalize.css">
<link rel="stylesheet" type="text/css" href="../../rustdoc.css">
<link rel="stylesheet" type="text/css" href="../../main.css">
<link rel="shortcut icon" href=
"https://doc.rust-lang.org/favicon.ico">
</head>
<body class="rustdoc">
<!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
<nav class="sidebar"><a href='../../std/index.html'><img src=
'https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=
'logo' width='100'></a>
<p class='location'><a href='../index.html'>std</a>::<wbr><a href=
'index.html'>ptr</a></p>
<script>
window.sidebarCurrent = {name: 'Unique', ty: 'struct', relpath: ''};
</script>
<script defer src="sidebar-items.js"></script></nav>
<nav class="sub">
<form class="search-form js-only">
<div class="search-container"><input class="search-input" name=
"search" autocomplete="off" placeholder=
"Click or press ‘S’ to search, ‘?’ for more options…" type=
"search"></div>
</form>
</nav>
<section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href=
'../index.html'>std</a>::<wbr><a href=
'index.html'>ptr</a>::<wbr><a class="struct" href=
''>Unique</a></span><span class='out-of-band'> <span id=
'render-detail'><a id="toggle-all-docs" href="javascript:void(0)"
title="collapse all docs">[<span class='inner'>−</span>]</a></span>
<a class='srclink' href='../../src/core/ptr.rs.html#899-907' title=
'goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Unique&lt;T&gt; <span class=
"where fmt-newline">where T: ?<a class="trait" href=
"../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span> { /* fields omitted */ }</pre>
<div class='stability'>
<div class='stab unstable'>
<details>
<summary><span class="microscope">🔬</span> This is a nightly-only
experimental API. (<code>unique</code> <a href=
"https://github.com/rust-lang/rust/issues/27730">#27730</a>)</summary>
<p>needs an RFC to flesh out design</p>
</details>
</div>
</div>
<div class='docblock'>
<p>A wrapper around a raw non-null <code>*mut T</code> that
indicates that the possessor of this wrapper owns the referent.
This in turn implies that the <code>Unique&lt;T&gt;</code> is
<code>Send</code>/<code>Sync</code> if <code>T</code> is
<code>Send</code>/<code>Sync</code>, unlike a raw <code>*mut
T</code> (which conveys no particular ownership semantics). It also
implies that the referent of the pointer should not be modified
without a unique path to the <code>Unique</code> reference. Useful
for building abstractions like <code>Vec&lt;T&gt;</code> or
<code>Box&lt;T&gt;</code>, which internally use raw pointers to
manage the memory that they own.</p>
</div>
<h2 id='methods'>Methods</h2>
<h3 class='impl'><span class='in-band'><code>impl&lt;T&gt;
<a class="struct" href="../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt; <span class=
"where fmt-newline">where T: ?<a class="trait" href=
"../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span></code></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#924-943' title=
'goto source code'>[src]</a></h3>
</div>
<div class='impl-items'>
<h4 id='method.new' class="method"><span class=
'out-of-band'><span id='new.v' class='invisible'><code>const unsafe
fn <a href='#method.new' class='fnname'>new</a>(ptr: <a class=
"primitive" href="../primitive.pointer.html">*mut T</a>) -&gt;
<a class="struct" href="../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt;</code></span></span></h4>
<div class='stability'>
<div class='stab unstable'><span class="microscope">🔬</span> This
is a nightly-only experimental API. (<code>unique</code> <a href=
"https://github.com/rust-lang/rust/issues/27730">#27730</a>)</div>
</div>
<div class='docblock'>
<p>Creates a new <code>Unique</code>.</p>
<h1 id='safety' class='section-header'><a href=
'#safety'>Safety</a></h1>
<p><code>ptr</code> must be non-null.</p>
</div>
<h4 id='method.get' class="method"><span id='get.v' class=
'invisible'><code>unsafe fn <a href='#method.get' class=
'fnname'>get</a>(&amp;self) -&gt; &amp;T</code></span></h4>
<div class='stability'>
<div class='stab unstable'><span class="microscope">🔬</span> This
is a nightly-only experimental API. (<code>unique</code> <a href=
"https://github.com/rust-lang/rust/issues/27730">#27730</a>)</div>
</div>
<div class='docblock'>
<p>Dereferences the content.</p>
</div>
<h4 id='method.get_mut' class="method"><span id='get_mut.v' class=
'invisible'><code>unsafe fn <a href='#method.get_mut' class=
'fnname'>get_mut</a>(&amp;mut self) -&gt; &amp;mut
T</code></span></h4>
<div class='stability'>
<div class='stab unstable'><span class="microscope">🔬</span> This
is a nightly-only experimental API. (<code>unique</code> <a href=
"https://github.com/rust-lang/rust/issues/27730">#27730</a>)</div>
</div>
<div class='docblock'>
<p>Mutably dereferences the content.</p>
</div>
</div>
<h2 id='deref-methods'>Methods from <a class="trait" href=
"../../std/ops/trait.Deref.html" title=
"trait std::ops::Deref">Deref</a>&lt;Target = <a class="primitive"
href="../primitive.pointer.html">*mut T</a>&gt;</h2>
<div class='impl-items'>
<h4 id='method.is_null' class="method"><span id='is_null.v' class=
'invisible'><code>fn <a href='#method.is_null' class=
'fnname'>is_null</a>(self) -&gt; <a class="primitive" href=
"../primitive.bool.html">bool</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.0.0'>
<h4 id='method.is_null' class="method">1.0.0</h4>
</div>
<div class='docblock'><span id='is_null.v' class=
'invisible'></span>
<p><span id='is_null.v' class='invisible'>Returns <code>true</code>
if the pointer is null.</span></p>
<h1 id='examples' class='section-header'><span id='is_null.v'
class='invisible'><a href='#examples'>Examples</a></span></h1>
<p><span id='is_null.v' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='is_null.v' class=
'invisible'>
<span class="kw">let</span> <span class=
"ident">s</span>: <span class="kw-2">&</span><span class=
"ident">str</span> <span class="op">=</span> <span class=
"string">"Follow the rabbit"</span>;
<span class="kw">let</span> <span class=
"ident">ptr</span>: <span class="kw-2">*</span><span class=
"kw">const</span> <span class="ident">u8</span> <span class=
"op">=</span> <span class="ident">s</span>.<span class=
"ident">as_ptr</span>();
<span class="macro">assert</span><span class=
"macro">!</span>(<span class="op">!</span><span class=
"ident">ptr</span>.<span class="ident">is_null</span>());<a class=
"test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22Follow%20the%20rabbit%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D">Run</a></span></pre></div>
<h4 id='method.as_ref' class="method"><span id='as_ref.v' class=
'invisible'><code>unsafe fn <a href='#method.as_ref' class=
'fnname'>as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href=
"../../std/option/enum.Option.html" title=
"enum std::option::Option">Option</a>&lt;&amp;'a
T&gt;</code></span></h4>
<div class='since' title='Stable since Rust version 1.9.0'>
<h4 id='method.as_ref' class="method">1.9.0</h4>
</div>
<div class='docblock'><span id='as_ref.v' class='invisible'></span>
<p><span id='as_ref.v' class='invisible'>Returns <code>None</code>
if the pointer is null, or else returns a reference to the value
wrapped in <code>Some</code>.</span></p>
<h1 id='safety-1' class='section-header'><span id='as_ref.v' class=
'invisible'><a href='#safety-1'>Safety</a></span></h1>
<p><span id='as_ref.v' class='invisible'>While this method and its
mutable counterpart are useful for null-safety, it is important to
note that this is still an unsafe operation because the returned
value could be pointing to invalid memory.</span></p>
<p><span id='as_ref.v' class='invisible'>Additionally, the lifetime
<code>'a</code> returned is arbitrarily chosen and does not
necessarily reflect the actual lifetime of the data.</span></p>
<h1 id='examples-1' class='section-header'><span id='as_ref.v'
class='invisible'><a href='#examples-1'>Examples</a></span></h1>
<p><span id='as_ref.v' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='as_ref.v' class=
'invisible'>
<span class="kw">let</span> <span class=
"ident">val</span>: <span class="kw-2">*</span><span class=
"kw">const</span> <span class="ident">u8</span> <span class=
"op">=</span> <span class="kw-2">&</span><span class=
"number">10u8</span> <span class="kw">as</span> <span class=
"kw-2">*</span><span class="kw">const</span> <span class=
"ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class=
"kw">let</span> <span class="prelude-val">Some</span>(<span class=
"ident">val_back</span>) <span class="op">=</span> <span class=
"ident">val</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println</span><span class=
"macro">!</span>(<span class=
"string">"We got back the value: {}!"</span>, <span class=
"ident">val_back</span>);
    }
}<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20val%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20val.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></span></pre></div>
<h4 id='method.offset' class="method"><span id='offset.v' class=
'invisible'><code>unsafe fn <a href='#method.offset' class=
'fnname'>offset</a>(self, count: <a class="primitive" href=
"../primitive.isize.html">isize</a>) -&gt; <a class="primitive"
href="../primitive.pointer.html">*const T</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.0.0'>
<h4 id='method.offset' class="method">1.0.0</h4>
</div>
<div class='docblock'><span id='offset.v' class='invisible'></span>
<p><span id='offset.v' class='invisible'>Calculates the offset from
a pointer. <code>count</code> is in units of T; e.g. a
<code>count</code> of 3 represents a pointer offset of <code>3 *
size_of::&lt;T&gt;()</code> bytes.</span></p>
<h1 id='safety-2' class='section-header'><span id='offset.v' class=
'invisible'><a href='#safety-2'>Safety</a></span></h1>
<p><span id='offset.v' class='invisible'>Both the starting and
resulting pointer must be either in bounds or one byte past the end
of an allocated object. If either pointer is out of bounds or
arithmetic overflow occurs then any further use of the returned
value will result in undefined behavior.</span></p>
<h1 id='examples-2' class='section-header'><span id='offset.v'
class='invisible'><a href='#examples-2'>Examples</a></span></h1>
<p><span id='offset.v' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='offset.v' class=
'invisible'>
<span class="kw">let</span> <span class=
"ident">s</span>: <span class="kw-2">&</span><span class=
"ident">str</span> <span class="op">=</span> <span class=
"string">"123"</span>;
<span class="kw">let</span> <span class=
"ident">ptr</span>: <span class="kw-2">*</span><span class=
"kw">const</span> <span class="ident">u8</span> <span class=
"op">=</span> <span class="ident">s</span>.<span class=
"ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class=
"macro">!</span>(<span class="string">"{}"</span>, <span class=
"kw-2">*</span><span class="ident">ptr</span>.<span class=
"ident">offset</span>(<span class="number">1</span>) <span class=
"kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class=
"macro">!</span>(<span class="string">"{}"</span>, <span class=
"kw-2">*</span><span class="ident">ptr</span>.<span class=
"ident">offset</span>(<span class="number">2</span>) <span class=
"kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2)%20as%20char)%3B%0A%7D%0A%7D">Run</a></span></pre></div>
<h4 id='method.wrapping_offset' class="method"><span id=
'wrapping_offset.v' class='invisible'><code>fn <a href=
'#method.wrapping_offset' class='fnname'>wrapping_offset</a>(self,
count: <a class="primitive" href=
"../primitive.isize.html">isize</a>) -&gt; <a class="primitive"
href="../primitive.pointer.html">*const T</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.16.0'>
<h4 id='method.wrapping_offset' class="method">1.16.0</h4>
</div>
<div class='docblock'><span id='wrapping_offset.v' class=
'invisible'></span>
<p><span id='wrapping_offset.v' class='invisible'>Calculates the
offset from a pointer using wrapping arithmetic. <code>count</code>
is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code>
bytes.</span></p>
<h1 id='safety-3' class='section-header'><span id=
'wrapping_offset.v' class='invisible'><a href=
'#safety-3'>Safety</a></span></h1>
<p><span id='wrapping_offset.v' class='invisible'>The resulting
pointer does not need to be in bounds, but it is potentially
hazardous to dereference (which requires
<code>unsafe</code>).</span></p>
<p><span id='wrapping_offset.v' class='invisible'>Always use
<code>.offset(count)</code> instead when possible, because
<code>offset</code> allows the compiler to optimize
better.</span></p>
<h1 id='examples-3' class='section-header'><span id=
'wrapping_offset.v' class='invisible'><a href=
'#examples-3'>Examples</a></span></h1>
<p><span id='wrapping_offset.v' class='invisible'>Basic
usage:</span></p>
<pre class="rust rust-example-rendered"><span id=
'wrapping_offset.v' class='invisible'>
<span class=
"comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class=
"ident">data</span> <span class="op">=</span> [<span class=
"number">1u8</span>, <span class="number">2</span>, <span class=
"number">3</span>, <span class="number">4</span>, <span class=
"number">5</span>];
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">ptr</span>: <span class=
"kw-2">*</span><span class="kw">const</span> <span class=
"ident">u8</span> <span class="op">=</span> <span class=
"ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class=
"ident">step</span> <span class="op">=</span> <span class=
"number">2</span>;
<span class="kw">let</span> <span class=
"ident">end_rounded_up</span> <span class=
"op">=</span> <span class="ident">ptr</span>.<span class=
"ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="comment">// This loop prints "1, 3, 5, "</span>
<span class="kw">while</span> <span class=
"ident">ptr</span> <span class="op">!=</span> <span class=
"ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class=
"macro">!</span>(<span class="string">"{}, "</span>, <span class=
"kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class=
"op">=</span> <span class="ident">ptr</span>.<span class=
"ident">wrapping_offset</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0A%7D">Run</a></span></pre></div>
</div>
<div class='impl-items'>
<h4 id='method.is_null-1' class="method"><span id='is_null.v-1'
class='invisible'><code>fn <a href='#method.is_null-1' class=
'fnname'>is_null</a>(self) -&gt; <a class="primitive" href=
"../primitive.bool.html">bool</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.0.0'>
<h4 id='method.is_null-1' class="method">1.0.0</h4>
</div>
<div class='docblock'><span id='is_null.v-1' class=
'invisible'></span>
<p><span id='is_null.v-1' class='invisible'>Returns
<code>true</code> if the pointer is null.</span></p>
<h1 id='examples-4' class='section-header'><span id='is_null.v-1'
class='invisible'><a href='#examples-4'>Examples</a></span></h1>
<p><span id='is_null.v-1' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='is_null.v-1'
class='invisible'>
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">s</span> <span class=
"op">=</span> [<span class="number">1</span>, <span class=
"number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class=
"ident">ptr</span>: <span class="kw-2">*</span><span class=
"kw-2">mut</span> <span class="ident">u32</span> <span class=
"op">=</span> <span class="ident">s</span>.<span class=
"ident">as_mut_ptr</span>();
<span class="macro">assert</span><span class=
"macro">!</span>(<span class="op">!</span><span class=
"ident">ptr</span>.<span class="ident">is_null</span>());<a class=
"test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D">Run</a></span></pre></div>
<h4 id='method.as_ref-1' class="method"><span id='as_ref.v-1'
class='invisible'><code>unsafe fn <a href='#method.as_ref-1' class=
'fnname'>as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href=
"../../std/option/enum.Option.html" title=
"enum std::option::Option">Option</a>&lt;&amp;'a
T&gt;</code></span></h4>
<div class='since' title='Stable since Rust version 1.9.0'>
<h4 id='method.as_ref-1' class="method">1.9.0</h4>
</div>
<div class='docblock'><span id='as_ref.v-1' class=
'invisible'></span>
<p><span id='as_ref.v-1' class='invisible'>Returns
<code>None</code> if the pointer is null, or else returns a
reference to the value wrapped in <code>Some</code>.</span></p>
<h1 id='safety-4' class='section-header'><span id='as_ref.v-1'
class='invisible'><a href='#safety-4'>Safety</a></span></h1>
<p><span id='as_ref.v-1' class='invisible'>While this method and
its mutable counterpart are useful for null-safety, it is important
to note that this is still an unsafe operation because the returned
value could be pointing to invalid memory.</span></p>
<p><span id='as_ref.v-1' class='invisible'>Additionally, the
lifetime <code>'a</code> returned is arbitrarily chosen and does
not necessarily reflect the actual lifetime of the data.</span></p>
<h1 id='examples-5' class='section-header'><span id='as_ref.v-1'
class='invisible'><a href='#examples-5'>Examples</a></span></h1>
<p><span id='as_ref.v-1' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='as_ref.v-1'
class='invisible'>
<span class="kw">let</span> <span class=
"ident">val</span>: <span class="kw-2">*</span><span class=
"kw-2">mut</span> <span class="ident">u8</span> <span class=
"op">=</span> <span class="kw-2">&</span><span class=
"kw-2">mut</span> <span class="number">10u8</span> <span class=
"kw">as</span> <span class="kw-2">*</span><span class=
"kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class=
"kw">let</span> <span class="prelude-val">Some</span>(<span class=
"ident">val_back</span>) <span class="op">=</span> <span class=
"ident">val</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println</span><span class=
"macro">!</span>(<span class=
"string">"We got back the value: {}!"</span>, <span class=
"ident">val_back</span>);
    }
}<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20val%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20val.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></span></pre></div>
<h4 id='method.offset-1' class="method"><span id='offset.v-1'
class='invisible'><code>unsafe fn <a href='#method.offset-1' class=
'fnname'>offset</a>(self, count: <a class="primitive" href=
"../primitive.isize.html">isize</a>) -&gt; <a class="primitive"
href="../primitive.pointer.html">*mut T</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.0.0'>
<h4 id='method.offset-1' class="method">1.0.0</h4>
</div>
<div class='docblock'><span id='offset.v-1' class=
'invisible'></span>
<p><span id='offset.v-1' class='invisible'>Calculates the offset
from a pointer. <code>count</code> is in units of T; e.g. a
<code>count</code> of 3 represents a pointer offset of <code>3 *
size_of::&lt;T&gt;()</code> bytes.</span></p>
<h1 id='safety-5' class='section-header'><span id='offset.v-1'
class='invisible'><a href='#safety-5'>Safety</a></span></h1>
<p><span id='offset.v-1' class='invisible'>The offset must be
in-bounds of the object, or one-byte-past-the-end. Otherwise
<code>offset</code> invokes Undefined Behavior, regardless of
whether the pointer is used.</span></p>
<h1 id='examples-6' class='section-header'><span id='offset.v-1'
class='invisible'><a href='#examples-6'>Examples</a></span></h1>
<p><span id='offset.v-1' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='offset.v-1'
class='invisible'>
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">s</span> <span class=
"op">=</span> [<span class="number">1</span>, <span class=
"number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class=
"ident">ptr</span>: <span class="kw-2">*</span><span class=
"kw-2">mut</span> <span class="ident">u32</span> <span class=
"op">=</span> <span class="ident">s</span>.<span class=
"ident">as_mut_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class=
"macro">!</span>(<span class="string">"{}"</span>, <span class=
"kw-2">*</span><span class="ident">ptr</span>.<span class=
"ident">offset</span>(<span class="number">1</span>));
    <span class="macro">println</span><span class=
"macro">!</span>(<span class="string">"{}"</span>, <span class=
"kw-2">*</span><span class="ident">ptr</span>.<span class=
"ident">offset</span>(<span class="number">2</span>));
}<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1))%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2))%3B%0A%7D%0A%7D">Run</a></span></pre></div>
<h4 id='method.wrapping_offset-1' class="method"><span id=
'wrapping_offset.v-1' class='invisible'><code>fn <a href=
'#method.wrapping_offset-1' class=
'fnname'>wrapping_offset</a>(self, count: <a class="primitive"
href="../primitive.isize.html">isize</a>) -&gt; <a class=
"primitive" href="../primitive.pointer.html">*mut
T</a></code></span></h4>
<div class='since' title='Stable since Rust version 1.16.0'>
<h4 id='method.wrapping_offset-1' class="method">1.16.0</h4>
</div>
<div class='docblock'><span id='wrapping_offset.v-1' class=
'invisible'></span>
<p><span id='wrapping_offset.v-1' class='invisible'>Calculates the
offset from a pointer using wrapping arithmetic. <code>count</code>
is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code>
bytes.</span></p>
<h1 id='safety-6' class='section-header'><span id=
'wrapping_offset.v-1' class='invisible'><a href=
'#safety-6'>Safety</a></span></h1>
<p><span id='wrapping_offset.v-1' class='invisible'>The resulting
pointer does not need to be in bounds, but it is potentially
hazardous to dereference (which requires
<code>unsafe</code>).</span></p>
<p><span id='wrapping_offset.v-1' class='invisible'>Always use
<code>.offset(count)</code> instead when possible, because
<code>offset</code> allows the compiler to optimize
better.</span></p>
<h1 id='examples-7' class='section-header'><span id=
'wrapping_offset.v-1' class='invisible'><a href=
'#examples-7'>Examples</a></span></h1>
<p><span id='wrapping_offset.v-1' class='invisible'>Basic
usage:</span></p>
<pre class="rust rust-example-rendered"><span id=
'wrapping_offset.v-1' class='invisible'>
<span class=
"comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">data</span> <span class=
"op">=</span> [<span class="number">1u8</span>, <span class=
"number">2</span>, <span class="number">3</span>, <span class=
"number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">ptr</span>: <span class=
"kw-2">*</span><span class="kw-2">mut</span> <span class=
"ident">u8</span> <span class="op">=</span> <span class=
"ident">data</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class=
"ident">step</span> <span class="op">=</span> <span class=
"number">2</span>;
<span class="kw">let</span> <span class=
"ident">end_rounded_up</span> <span class=
"op">=</span> <span class="ident">ptr</span>.<span class=
"ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="kw">while</span> <span class=
"ident">ptr</span> <span class="op">!=</span> <span class=
"ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="kw-2">*</span><span class=
"ident">ptr</span> <span class="op">=</span> <span class=
"number">0</span>;
    }
    <span class="ident">ptr</span> <span class=
"op">=</span> <span class="ident">ptr</span>.<span class=
"ident">wrapping_offset</span>(<span class="ident">step</span>);
}
<span class="macro">assert_eq</span><span class=
"macro">!</span>(<span class="kw-2">&</span><span class=
"ident">data</span>, <span class="kw-2">&</span>[<span class=
"number">0</span>, <span class="number">2</span>, <span class=
"number">0</span>, <span class="number">4</span>, <span class=
"number">0</span>]);<a class="test-arrow" target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Alet%20mut%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*mut%20u8%20%3D%20data.as_mut_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20*ptr%20%3D%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0Aassert_eq!(%26data%2C%20%26%5B0%2C%202%2C%200%2C%204%2C%200%5D)%3B%0A%7D">Run</a></span></pre></div>
<h4 id='method.as_mut' class="method"><span id='as_mut.v' class=
'invisible'><code>unsafe fn <a href='#method.as_mut' class=
'fnname'>as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href=
"../../std/option/enum.Option.html" title=
"enum std::option::Option">Option</a>&lt;&amp;'a mut
T&gt;</code></span></h4>
<div class='since' title='Stable since Rust version 1.9.0'>
<h4 id='method.as_mut' class="method">1.9.0</h4>
</div>
<div class='docblock'><span id='as_mut.v' class='invisible'></span>
<p><span id='as_mut.v' class='invisible'>Returns <code>None</code>
if the pointer is null, or else returns a mutable reference to the
value wrapped in <code>Some</code>.</span></p>
<h1 id='safety-7' class='section-header'><span id='as_mut.v' class=
'invisible'><a href='#safety-7'>Safety</a></span></h1>
<p><span id='as_mut.v' class='invisible'>As with
<code>as_ref</code>, this is unsafe because it cannot verify the
validity of the returned pointer, nor can it ensure that the
lifetime <code>'a</code> returned is indeed a valid lifetime for
the contained data.</span></p>
<h1 id='examples-8' class='section-header'><span id='as_mut.v'
class='invisible'><a href='#examples-8'>Examples</a></span></h1>
<p><span id='as_mut.v' class='invisible'>Basic usage:</span></p>
<pre class="rust rust-example-rendered"><span id='as_mut.v' class=
'invisible'>
<span class="kw">let</span> <span class=
"kw-2">mut</span> <span class="ident">s</span> <span class=
"op">=</span> [<span class="number">1</span>, <span class=
"number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class=
"ident">ptr</span>: <span class="kw-2">*</span><span class=
"kw-2">mut</span> <span class="ident">u32</span> <span class=
"op">=</span> <span class="ident">s</span>.<span class=
"ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class=
"ident">first_value</span> <span class="op">=</span> <span class=
"kw">unsafe</span> { <span class="ident">ptr</span>.<span class=
"ident">as_mut</span>().<span class="ident">unwrap</span>() };
<span class="kw-2">*</span><span class=
"ident">first_value</span> <span class="op">=</span> <span class=
"number">4</span>;
<span class="macro">println</span><span class=
"macro">!</span>(<span class="string">"{:?}"</span>, <span class=
"ident">s</span>); <span class=
"comment">// It'll print: "[4, 2, 3]".</span><a class="test-arrow"
target="_blank" href=
"https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20ptr.as_mut().unwrap()%20%7D%3B%0A*first_value%20%3D%204%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20It'll%20print%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D">Run</a></span></pre></div>
</div>
<h2 id='implementations'>Trait Implementations</h2>
<h3 class='impl'><span class='in-band'><code>impl&lt;T&gt;
<a class="trait" href="../../std/marker/trait.Send.html" title=
"trait std::marker::Send">Send</a> for <a class="struct" href=
"../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt; <span class=
"where fmt-newline">where T: <a class="trait" href=
"../../std/marker/trait.Send.html" title=
"trait std::marker::Send">Send</a> + ?<a class="trait" href=
"../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span></code></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#914' title=
'goto source code'>[src]</a></h3>
</div>
<div class='docblock'>
<p><span class='out-of-band'><code>Unique</code> pointers are
<code>Send</code> if <code>T</code> is <code>Send</code> because
the data they reference is unaliased. Note that this aliasing
invariant is unenforced by the type system; the abstraction using
the <code>Unique</code> must enforce it.</span></p>
</div>
<div class='impl-items'></div>
<h3 class='impl'><span class='out-of-band'><span class=
'in-band'><code>impl&lt;T&gt; <a class="trait" href=
"../../std/ops/trait.Deref.html" title=
"trait std::ops::Deref">Deref</a> for <a class="struct" href=
"../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt; <span class=
"where fmt-newline">where T: ?<a class="trait" href=
"../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span></code></span></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#949-956' title=
'goto source code'>[src]</a></h3>
</div>
<div class='impl-items'>
<h4 id='associatedtype.Target' class="type"><span class=
'out-of-band'><span id='Target.t' class='invisible'><code>type
<a href='../../std/ops/trait.Deref.html#associatedtype.Target'
class="type">Target</a> = <a class="primitive" href=
"../primitive.pointer.html">*mut T</a></code></span></span></h4>
<div class='docblock'>
<p>The resulting type after dereferencing</p>
</div>
<h4 id='method.deref' class="method"><span id='deref.v' class=
'invisible'><code>fn <a href=
'../../std/ops/trait.Deref.html#tymethod.deref' class=
'fnname'>deref</a>(&amp;self) -&gt; &<a class="primitive" href=
"../primitive.pointer.html">*mut T</a></code></span></h4>
<div class='docblock'>
<p>The method called to dereference a value</p>
</div>
</div>
<h3 class='impl'><span class='in-band'><code>impl&lt;T&gt;
<a class="trait" href="../../std/marker/trait.Sync.html" title=
"trait std::marker::Sync">Sync</a> for <a class="struct" href=
"../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt; <span class=
"where fmt-newline">where T: <a class="trait" href=
"../../std/marker/trait.Sync.html" title=
"trait std::marker::Sync">Sync</a> + ?<a class="trait" href=
"../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span></code></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#921' title=
'goto source code'>[src]</a></h3>
</div>
<div class='docblock'>
<p><span class='out-of-band'><code>Unique</code> pointers are
<code>Sync</code> if <code>T</code> is <code>Sync</code> because
the data they reference is unaliased. Note that this aliasing
invariant is unenforced by the type system; the abstraction using
the <code>Unique</code> must enforce it.</span></p>
</div>
<div class='impl-items'></div>
<h3 class='impl'><span class='out-of-band'><span class=
'in-band'><code>impl&lt;T&gt; <a class="trait" href=
"../../std/fmt/trait.Pointer.html" title=
"trait std::fmt::Pointer">Pointer</a> for <a class="struct" href=
"../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt;</code></span></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#959-963' title=
'goto source code'>[src]</a></h3>
</div>
<div class='impl-items'>
<h4 id='method.fmt' class="method"><span class=
'out-of-band'><span id='fmt.v' class='invisible'><code>fn <a href=
'../../std/fmt/trait.Pointer.html#tymethod.fmt' class=
'fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href=
"../../std/fmt/struct.Formatter.html" title=
"struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum"
href="../../std/result/enum.Result.html" title=
"enum std::result::Result">Result</a>&lt;<a class="primitive" href=
"../primitive.tuple.html">()</a>, <a class="struct" href=
"../../std/fmt/struct.Error.html" title=
"struct std::fmt::Error">Error</a>&gt;</code></span></span></h4>
<div class='docblock'>
<p>Formats the value using the given formatter.</p>
</div>
</div>
<h3 class='impl'><span class='in-band'><code>impl&lt;T, U&gt;
<a class="trait" href="../../std/ops/trait.CoerceUnsized.html"
title=
"trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="struct"
href="../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;U&gt;&gt; for <a class=
"struct" href="../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt; <span class=
"where fmt-newline">where T: <a class="trait" href=
"../../std/marker/trait.Unsize.html" title=
"trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait"
href="../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class=
"trait" href="../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a></span></code></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/core/ptr.rs.html#946' title=
'goto source code'>[src]</a></h3>
</div>
<div class='impl-items'></div>
<h3 class='impl'><span class='out-of-band'><span class=
'in-band'><code>impl&lt;T:&nbsp;<a class="trait" href=
"../../std/panic/trait.UnwindSafe.html" title=
"trait std::panic::UnwindSafe">UnwindSafe</a> + ?<a class="trait"
href="../../std/marker/trait.Sized.html" title=
"trait std::marker::Sized">Sized</a>&gt; <a class="trait" href=
"../../std/panic/trait.UnwindSafe.html" title=
"trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct"
href="../../std/ptr/struct.Unique.html" title=
"struct std::ptr::Unique">Unique</a>&lt;T&gt;</code></span></span></h3>
<div class='ghost'>
<h3 class='impl'><a class='srclink' href=
'../../src/std/panic.rs.html#201' title=
'goto source code'>[src]</a></h3>
</div>
<div class='impl-items'></div>
</section>
<section id='search' class="content hidden"></section>
<section class="footer"></section>
<aside id="help" class="hidden">
<div>
<h1 class="hidden"><span class='out-of-band'>Help</span></h1>
<div class="shortcuts">
<h2><span class='out-of-band'>Keyboard Shortcuts</span></h2>
<dl>
<dt><span class='out-of-band'>?</span></dt>
<dd><span class='out-of-band'>Show this help dialog</span></dd>
<dt><span class='out-of-band'>S</span></dt>
<dd><span class='out-of-band'>Focus the search field</span></dd>
<dt><span class='out-of-band'>&amp;larrb;</span></dt>
<dd><span class='out-of-band'>Move up in search results</span></dd>
<dt><span class='out-of-band'>&amp;rarrb;</span></dt>
<dd><span class='out-of-band'>Move down in search
results</span></dd>
<dt><span class='out-of-band'>⏎</span></dt>
<dd><span class='out-of-band'>Go to active search
result</span></dd>
<dt><span class='out-of-band'>+</span></dt>
<dd><span class='out-of-band'>Collapse/expand all
sections</span></dd>
</dl>
</div>
<div class="infos">
<h2><span class='out-of-band'>Search Tricks</span></h2>
<p><span class='out-of-band'>Prefix searches with a type followed
by a colon (e.g. <code>fn:</code>) to restrict the search to a
given type.</span></p>
<p><span class='out-of-band'>Accepted types are: <code>fn</code>,
<code>mod</code>, <code>struct</code>, <code>enum</code>,
<code>trait</code>, <code>type</code>, <code>macro</code>, and
<code>const</code>.</span></p>
<p><span class='out-of-band'>Search functions by type signature
(e.g. <code>vec -&gt; usize</code> or <code>* -&gt;
vec</code>)</span></p>
</div>
</div>
</aside>
<span class='out-of-band'>
<script>
        window.rootPath = "../../";
        window.currentCrate = "std";
</script> 
<script src="../../jquery.js"></script> 
<script src="../../main.js"></script> 
<script defer src="../../search-index.js"></script></span>
</body>
</html>
