<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Windows version 5.5.12">
<meta charset="UTF-8">
<title>windows_subsystem -</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="description" content="">
<meta name="viewport" content=
"width=device-width, initial-scale=1">
<base href="">
<link rel="stylesheet" href="book.css">
<link href=
'https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
rel='stylesheet' type='text/css'>
<link rel="shortcut icon" href="favicon.png"><!-- Font Awesome -->
<link rel="stylesheet" href=
"https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<link rel="stylesheet" href="highlight.css">
<link rel="stylesheet" href="tomorrow-night.css"><!-- MathJax -->

<script type="text/javascript" src=
"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- Fetch JQuery from CDN but have a local fallback -->

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
</script>
</head>
<body class="light">
<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
</script> <!-- Hide / unhide sidebar before it is displayed -->
 
<script type="text/javascript">

            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
</script>
<div id="sidebar" class="sidebar">
<ul class="chapter">
<li class="affix"><a href="the-unstable-book.html">The Unstable
Book</a></li>
<li><a href="abi-msp430-interrupt.html"><strong>1.</strong>
abi_msp430_interrupt</a></li>
<li><a href="abi-ptx.html"><strong>2.</strong> abi_ptx</a></li>
<li><a href="abi-sysv64.html"><strong>3.</strong>
abi_sysv64</a></li>
<li><a href="abi-unadjusted.html"><strong>4.</strong>
abi_unadjusted</a></li>
<li><a href="abi-vectorcall.html"><strong>5.</strong>
abi_vectorcall</a></li>
<li><a href="abi-x86-interrupt.html"><strong>6.</strong>
abi_x86_interrupt</a></li>
<li><a href="advanced-slice-patterns.html"><strong>7.</strong>
advanced_slice_patterns</a></li>
<li><a href="alloc-jemalloc.html"><strong>8.</strong>
alloc_jemalloc</a></li>
<li><a href="alloc-system.html"><strong>9.</strong>
alloc_system</a></li>
<li><a href="allocator.html"><strong>10.</strong>
allocator</a></li>
<li><a href="allow-internal-unstable.html"><strong>11.</strong>
allow_internal_unstable</a></li>
<li><a href="asm.html"><strong>12.</strong> asm</a></li>
<li><a href="associated-consts.html"><strong>13.</strong>
associated_consts</a></li>
<li><a href="associated-type-defaults.html"><strong>14.</strong>
associated_type_defaults</a></li>
<li><a href="attr-literals.html"><strong>15.</strong>
attr_literals</a></li>
<li><a href="box-patterns.html"><strong>16.</strong>
box_patterns</a></li>
<li><a href="box-syntax.html"><strong>17.</strong>
box_syntax</a></li>
<li><a href="cfg-target-feature.html"><strong>18.</strong>
cfg_target_feature</a></li>
<li><a href="cfg-target-has-atomic.html"><strong>19.</strong>
cfg_target_has_atomic</a></li>
<li><a href="cfg-target-thread-local.html"><strong>20.</strong>
cfg_target_thread_local</a></li>
<li><a href="cfg-target-vendor.html"><strong>21.</strong>
cfg_target_vendor</a></li>
<li><a href="compiler-builtins.html"><strong>22.</strong>
compiler_builtins</a></li>
<li><a href="concat-idents.html"><strong>23.</strong>
concat_idents</a></li>
<li><a href="conservative-impl-trait.html"><strong>24.</strong>
conservative_impl_trait</a></li>
<li><a href="const-fn.html"><strong>25.</strong> const_fn</a></li>
<li><a href="const-indexing.html"><strong>26.</strong>
const_indexing</a></li>
<li><a href="custom-attribute.html"><strong>27.</strong>
custom_attribute</a></li>
<li><a href="custom-derive.html"><strong>28.</strong>
custom_derive</a></li>
<li><a href=
"default-type-parameter-fallback.html"><strong>29.</strong>
default_type_parameter_fallback</a></li>
<li><a href="drop-types-in-const.html"><strong>30.</strong>
drop_types_in_const</a></li>
<li><a href="dropck-eyepatch.html"><strong>31.</strong>
dropck_eyepatch</a></li>
<li><a href="dropck-parametricity.html"><strong>32.</strong>
dropck_parametricity</a></li>
<li><a href="exclusive-range-pattern.html"><strong>33.</strong>
exclusive_range_pattern</a></li>
<li><a href="field-init-shorthand.html"><strong>34.</strong>
field_init_shorthand</a></li>
<li><a href="fundamental.html"><strong>35.</strong>
fundamental</a></li>
<li><a href="generic-param-attrs.html"><strong>36.</strong>
generic_param_attrs</a></li>
<li><a href="i128-type.html"><strong>37.</strong>
i128_type</a></li>
<li><a href="inclusive-range-syntax.html"><strong>38.</strong>
inclusive_range_syntax</a></li>
<li><a href="intrinsics.html"><strong>39.</strong>
intrinsics</a></li>
<li><a href="lang-items.html"><strong>40.</strong>
lang_items</a></li>
<li><a href="link-args.html"><strong>41.</strong>
link_args</a></li>
<li><a href="link-cfg.html"><strong>42.</strong> link_cfg</a></li>
<li><a href="link-llvm-intrinsics.html"><strong>43.</strong>
link_llvm_intrinsics</a></li>
<li><a href="linkage.html"><strong>44.</strong> linkage</a></li>
<li><a href="log-syntax.html"><strong>45.</strong>
log_syntax</a></li>
<li><a href="loop-break-value.html"><strong>46.</strong>
loop_break_value</a></li>
<li><a href="macro-reexport.html"><strong>47.</strong>
macro_reexport</a></li>
<li><a href="main.html"><strong>48.</strong> main</a></li>
<li><a href="naked-functions.html"><strong>49.</strong>
naked_functions</a></li>
<li><a href="needs-allocator.html"><strong>50.</strong>
needs_allocator</a></li>
<li><a href="needs-panic-runtime.html"><strong>51.</strong>
needs_panic_runtime</a></li>
<li><a href="never-type.html"><strong>52.</strong>
never_type</a></li>
<li><a href="no-core.html"><strong>53.</strong> no_core</a></li>
<li><a href="no-debug.html"><strong>54.</strong> no_debug</a></li>
<li><a href="non-ascii-idents.html"><strong>55.</strong>
non_ascii_idents</a></li>
<li><a href=
"omit-gdb-pretty-printer-section.html"><strong>56.</strong>
omit_gdb_pretty_printer_section</a></li>
<li><a href="on-unimplemented.html"><strong>57.</strong>
on_unimplemented</a></li>
<li><a href="optin-builtin-traits.html"><strong>58.</strong>
optin_builtin_traits</a></li>
<li><a href="panic-runtime.html"><strong>59.</strong>
panic_runtime</a></li>
<li><a href="placement-in-syntax.html"><strong>60.</strong>
placement_in_syntax</a></li>
<li><a href="platform-intrinsics.html"><strong>61.</strong>
platform_intrinsics</a></li>
<li><a href="plugin.html"><strong>62.</strong> plugin</a></li>
<li><a href="plugin-registrar.html"><strong>63.</strong>
plugin_registrar</a></li>
<li><a href="prelude-import.html"><strong>64.</strong>
prelude_import</a></li>
<li><a href="proc-macro.html"><strong>65.</strong>
proc_macro</a></li>
<li><a href="quote.html"><strong>66.</strong> quote</a></li>
<li><a href="relaxed-adts.html"><strong>67.</strong>
relaxed_adts</a></li>
<li><a href="repr-simd.html"><strong>68.</strong>
repr_simd</a></li>
<li><a href="rustc-attrs.html"><strong>69.</strong>
rustc_attrs</a></li>
<li><a href="rustc-diagnostic-macros.html"><strong>70.</strong>
rustc_diagnostic_macros</a></li>
<li><a href="rvalue-static-promotion.html"><strong>71.</strong>
rvalue_static_promotion</a></li>
<li><a href="sanitizer-runtime.html"><strong>72.</strong>
sanitizer_runtime</a></li>
<li><a href="simd.html"><strong>73.</strong> simd</a></li>
<li><a href="simd-ffi.html"><strong>74.</strong> simd_ffi</a></li>
<li><a href="slice-patterns.html"><strong>75.</strong>
slice_patterns</a></li>
<li><a href="sort-unstable.html"><strong>76.</strong>
sort_unstable</a></li>
<li><a href="specialization.html"><strong>77.</strong>
specialization</a></li>
<li><a href="staged-api.html"><strong>78.</strong>
staged_api</a></li>
<li><a href="start.html"><strong>79.</strong> start</a></li>
<li><a href="static-nobundle.html"><strong>80.</strong>
static_nobundle</a></li>
<li><a href="static-recursion.html"><strong>81.</strong>
static_recursion</a></li>
<li><a href="stmt-expr-attributes.html"><strong>82.</strong>
stmt_expr_attributes</a></li>
<li><a href="struct-field-attributes.html"><strong>83.</strong>
struct_field_attributes</a></li>
<li><a href="structural-match.html"><strong>84.</strong>
structural_match</a></li>
<li><a href="target-feature.html"><strong>85.</strong>
target_feature</a></li>
<li><a href="test.html"><strong>86.</strong> test</a></li>
<li><a href="thread-local.html"><strong>87.</strong>
thread_local</a></li>
<li><a href="trace-macros.html"><strong>88.</strong>
trace_macros</a></li>
<li><a href="type-ascription.html"><strong>89.</strong>
type_ascription</a></li>
<li><a href="unboxed-closures.html"><strong>90.</strong>
unboxed_closures</a></li>
<li><a href="untagged-unions.html"><strong>91.</strong>
untagged_unions</a></li>
<li><a href="unwind-attributes.html"><strong>92.</strong>
unwind_attributes</a></li>
<li><a href="use-extern-macros.html"><strong>93.</strong>
use_extern_macros</a></li>
<li><a href="windows-subsystem.html"><strong>94.</strong>
windows_subsystem</a></li>
</ul>
</div>
<div id="page-wrapper" class="page-wrapper">
<div class="page">
<div id="menu-bar" class="menu-bar">
<div class="left-buttons"><i id="sidebar-toggle" class=
"fa fa-bars"></i> <i id="theme-toggle" class=
"fa fa-paint-brush"></i></div>
<h1 class="menu-title"></h1>
<div class="right-buttons"><i id="print-button" class="fa fa-print"
title="Print this book"></i></div>
</div>
<div id="content" class="content">
<h1><a class="header" href="print.html#the-unstable-book" name=
"the-unstable-book" id="the-unstable-book">The Unstable
Book</a></h1>
<p>Welcome to the Unstable Book! This book consists of a number of
chapters, each one organized by a "feature flag." That is, when
using an unstable feature of Rust, you must use a flag, like
this:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(box_syntax)]

fn main() {
    let five = box 5;
}
</code></pre>
<p>The <code>box_syntax</code> feature <a href=
"box-syntax.html">has a chapter</a> describing how to use it.</p>
<p>Because this documentation relates to unstable features, we make
no guarantees that what is contained here is accurate or up to
date. It's developed on a best-effort basis. Each page will have a
link to its tracking issue with the latest developments; you might
want to check those as well.</p>
<h1><a class="header" href="print.html#abi_msp430_interrupt" name=
"abi_msp430_interrupt" id=
"abi_msp430_interrupt"><code>abi_msp430_interrupt</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/38487">#38487</a></p>
<hr>
<h1><a class="header" href="print.html#abi_ptx" name="abi_ptx" id=
"abi_ptx"><code>abi_ptx</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#abi_sysv64" name=
"abi_sysv64" id="abi_sysv64"><code>abi_sysv64</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/36167">#36167</a></p>
<hr>
<h1><a class="header" href="print.html#abi_unadjusted" name=
"abi_unadjusted" id=
"abi_unadjusted"><code>abi_unadjusted</code></a></h1>
<p>The tracking issue for this feature is: none.</p>
<hr>
<h1><a class="header" href="print.html#abi_vectorcall" name=
"abi_vectorcall" id=
"abi_vectorcall"><code>abi_vectorcall</code></a></h1>
<p>The tracking issue for this feature is: none.</p>
<hr>
<h1><a class="header" href="print.html#abi_x86_interrupt" name=
"abi_x86_interrupt" id=
"abi_x86_interrupt"><code>abi_x86_interrupt</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/40180">#40180</a></p>
<hr>
<h1><a class="header" href="print.html#advanced_slice_patterns"
name="advanced_slice_patterns" id=
"advanced_slice_patterns"><code>advanced_slice_patterns</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/23121">#23121</a></p>
<p>See also <a href=
"slice-patterns.html"><code>slice_patterns</code></a>.</p>
<hr>
<p>The <code>advanced_slice_patterns</code> gate lets you use
<code>..</code> to indicate any number of elements inside a pattern
matching a slice. This wildcard can only be used once for a given
array. If there's an identifier before the <code>..</code>, the
result of the slice will be bound to that name. For example:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(advanced_slice_patterns, slice_patterns)]

fn is_symmetric(list: &amp;[u32]) -&gt; bool {
    match list {
        &amp;[] | &amp;[_] =&gt; true,
        &amp;[x, ref inside.., y] if x == y =&gt; is_symmetric(inside),
        _ =&gt; false
    }
}

fn main() {
    let sym = &amp;[0, 1, 4, 2, 4, 1, 0];
    assert!(is_symmetric(sym));

    let not_sym = &amp;[0, 1, 7, 2, 4, 1, 0];
    assert!(!is_symmetric(not_sym));
}
</code></pre>
<h1><a class="header" href="print.html#alloc_jemalloc" name=
"alloc_jemalloc" id=
"alloc_jemalloc"><code>alloc_jemalloc</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/33082">#33082</a></p>
<p>See also <a href=
"alloc-system.html"><code>alloc_system</code></a>.</p>
<hr>
<p>The compiler currently ships two default allocators:
<code>alloc_system</code> and <code>alloc_jemalloc</code> (some
targets don't have jemalloc, however). These allocators are normal
Rust crates and contain an implementation of the routines to
allocate and deallocate memory. The standard library is not
compiled assuming either one, and the compiler will decide which
allocator is in use at compile-time depending on the type of output
artifact being produced.</p>
<p>Binaries generated by the compiler will use
<code>alloc_jemalloc</code> by default (where available). In this
situation the compiler "controls the world" in the sense of it has
power over the final link. Primarily this means that the allocator
decision can be left up the compiler.</p>
<p>Dynamic and static libraries, however, will use
<code>alloc_system</code> by default. Here Rust is typically a
'guest' in another application or another world where it cannot
authoritatively decide what allocator is in use. As a result it
resorts back to the standard APIs (e.g. <code>malloc</code> and
<code>free</code>) for acquiring and releasing memory.</p>
<h1><a class="header" href="print.html#switching-allocators" name=
"switching-allocators" id="switching-allocators">Switching
Allocators</a></h1>
<p>Although the compiler's default choices may work most of the
time, it's often necessary to tweak certain aspects. Overriding the
compiler's decision about which allocator is in use is done simply
by linking to the desired allocator:</p>
<pre class="playpen"><code class=
"language-rust no_run">#![feature(alloc_system)]

extern crate alloc_system;

fn main() {
    let a = Box::new(4); // Allocates from the system allocator.
    println!("{}", a);
}
</code></pre>
<p>In this example the binary generated will not link to jemalloc
by default but instead use the system allocator. Conversely to
generate a dynamic library which uses jemalloc by default one would
write:</p>
<pre><code class="language-rust ignore">#![feature(alloc_jemalloc)]
#![crate_type = "dylib"]

extern crate alloc_jemalloc;

pub fn foo() {
    let a = Box::new(4); // Allocates from jemalloc.
    println!("{}", a);
}
# fn main() {}
</code></pre>
<h1><a class="header" href="print.html#alloc_system" name=
"alloc_system" id="alloc_system"><code>alloc_system</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/33082">#33082</a></p>
<p>See also <a href=
"alloc-jemalloc.html"><code>alloc_jemalloc</code></a>.</p>
<hr>
<p>The compiler currently ships two default allocators:
<code>alloc_system</code> and <code>alloc_jemalloc</code> (some
targets don't have jemalloc, however). These allocators are normal
Rust crates and contain an implementation of the routines to
allocate and deallocate memory. The standard library is not
compiled assuming either one, and the compiler will decide which
allocator is in use at compile-time depending on the type of output
artifact being produced.</p>
<p>Binaries generated by the compiler will use
<code>alloc_jemalloc</code> by default (where available). In this
situation the compiler "controls the world" in the sense of it has
power over the final link. Primarily this means that the allocator
decision can be left up the compiler.</p>
<p>Dynamic and static libraries, however, will use
<code>alloc_system</code> by default. Here Rust is typically a
'guest' in another application or another world where it cannot
authoritatively decide what allocator is in use. As a result it
resorts back to the standard APIs (e.g. <code>malloc</code> and
<code>free</code>) for acquiring and releasing memory.</p>
<h1><a class="header" href="print.html#switching-allocators" name=
"switching-allocators" id="switching-allocators">Switching
Allocators</a></h1>
<p>Although the compiler's default choices may work most of the
time, it's often necessary to tweak certain aspects. Overriding the
compiler's decision about which allocator is in use is done simply
by linking to the desired allocator:</p>
<pre class="playpen"><code class=
"language-rust no_run">#![feature(alloc_system)]

extern crate alloc_system;

fn main() {
    let a = Box::new(4); // Allocates from the system allocator.
    println!("{}", a);
}
</code></pre>
<p>In this example the binary generated will not link to jemalloc
by default but instead use the system allocator. Conversely to
generate a dynamic library which uses jemalloc by default one would
write:</p>
<pre><code class="language-rust ignore">#![feature(alloc_jemalloc)]
#![crate_type = "dylib"]

extern crate alloc_jemalloc;

pub fn foo() {
    let a = Box::new(4); // Allocates from jemalloc.
    println!("{}", a);
}
# fn main() {}
</code></pre>
<h1><a class="header" href="print.html#allocator" name="allocator"
id="allocator"><code>allocator</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27389">#27389</a></p>
<hr>
<p>Sometimes even the choices of jemalloc vs the system allocator
aren't enough and an entirely new custom allocator is required. In
this you'll write your own crate which implements the allocator API
(e.g. the same as <code>alloc_system</code> or
<code>alloc_jemalloc</code>). As an example, let's take a look at a
simplified and annotated version of <code>alloc_system</code></p>
<pre class="playpen"><code class=
"language-rust no_run"># // Only needed for rustdoc --test down below.
# #![feature(lang_items)]
// The compiler needs to be instructed that this crate is an allocator in order
// to realize that when this is linked in another allocator like jemalloc should
// not be linked in.
#![feature(allocator)]
#![allocator]

// Allocators are not allowed to depend on the standard library which in turn
// requires an allocator in order to avoid circular dependencies. This crate,
// however, can use all of libcore.
#![no_std]

// Let's give a unique name to our custom allocator:
#![crate_name = "my_allocator"]
#![crate_type = "rlib"]

// Our system allocator will use the in-tree libc crate for FFI bindings. Note
// that currently the external (crates.io) libc cannot be used because it links
// to the standard library (e.g. `#![no_std]` isn't stable yet), so that's why
// this specifically requires the in-tree version.
#![feature(libc)]
extern crate libc;

// Listed below are the five allocation functions currently required by custom
// allocators. Their signatures and symbol names are not currently typechecked
// by the compiler, but this is a future extension and are required to match
// what is found below.
//
// Note that the standard `malloc` and `realloc` functions do not provide a way
// to communicate alignment so this implementation would need to be improved
// with respect to alignment in that aspect.

#[no_mangle]
pub extern fn __rust_allocate(size: usize, _align: usize) -&gt; *mut u8 {
    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }
}

#[no_mangle]
pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {
    unsafe { libc::free(ptr as *mut libc::c_void) }
}

#[no_mangle]
pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,
                                _align: usize) -&gt; *mut u8 {
    unsafe {
        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8
    }
}

#[no_mangle]
pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,
                                        _size: usize, _align: usize) -&gt; usize {
    old_size // This api is not supported by libc.
}

#[no_mangle]
pub extern fn __rust_usable_size(size: usize, _align: usize) -&gt; usize {
    size
}

# // Only needed to get rustdoc to test this:
# fn main() {}
# #[lang = "panic_fmt"] fn panic_fmt() {}
# #[lang = "eh_personality"] fn eh_personality() {}
# #[lang = "eh_unwind_resume"] extern fn eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre>
<p>After we compile this crate, it can be used as follows:</p>
<pre><code class="language-rust ignore">extern crate my_allocator;

fn main() {
    let a = Box::new(8); // Allocates memory via our custom allocator crate.
    println!("{}", a);
}
</code></pre>
<h2><a class="header" href=
"print.html#custom-allocator-limitations" name=
"custom-allocator-limitations" id=
"custom-allocator-limitations">Custom allocator
limitations</a></h2>
<p>There are a few restrictions when working with custom allocators
which may cause compiler errors:</p>
<ul>
<li>
<p>Any one artifact may only be linked to at most one allocator.
Binaries, dylibs, and staticlibs must link to exactly one
allocator, and if none have been explicitly chosen the compiler
will choose one. On the other hand rlibs do not need to link to an
allocator (but still can).</p>
</li>
<li>
<p>A consumer of an allocator is tagged with
<code>#![needs_allocator]</code> (e.g. the <code>liballoc</code>
crate currently) and an <code>#[allocator]</code> crate cannot
transitively depend on a crate which needs an allocator (e.g.
circular dependencies are not allowed). This basically means that
allocators must restrict themselves to libcore currently.</p>
</li>
</ul>
<h1><a class="header" href="print.html#allow_internal_unstable"
name="allow_internal_unstable" id=
"allow_internal_unstable"><code>allow_internal_unstable</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#asm" name="asm" id=
"asm"><code>asm</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29722">#29722</a></p>
<hr>
<p>For extremely low-level manipulations and performance reasons,
one might wish to control the CPU directly. Rust supports using
inline assembly to do this via the <code>asm!</code> macro.</p>
<pre><code class="language-rust ignore">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>
<p>Any use of <code>asm</code> is feature gated (requires
<code>#![feature(asm)]</code> on the crate to allow) and of course
requires an <code>unsafe</code> block.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64
assembly, but all platforms are supported.</p>
</blockquote>
<h2><a class="header" href="print.html#assembly-template" name=
"assembly-template" id="assembly-template">Assembly
template</a></h2>
<p>The <code>assembly template</code> is the only required
parameter and must be a literal string (i.e. <code>""</code>)</p>
<pre class="playpen"><code class="language-rust">#![feature(asm)]

#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
fn foo() {
    unsafe {
        asm!("NOP");
    }
}

// Other platforms:
#[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</code></pre>
<p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are
omitted from now on.)</p>
<p>Output operands, input operands, clobbers and options are all
optional but you must add the right number of <code>:</code> if you
skip them:</p>
<pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
# fn main() { unsafe {
asm!("xor %eax, %eax"
    :
    :
    : "eax"
   );
# } }
# #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
# fn main() {}
</code></pre>
<p>Whitespace also doesn't matter:</p>
<pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
# fn main() { unsafe {
asm!("xor %eax, %eax" ::: "eax");
# } }
# #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
# fn main() {}
</code></pre>
<h2><a class="header" href="print.html#operands" name="operands"
id="operands">Operands</a></h2>
<p>Input and output operands follow the same format: <code>:
"constraints1"(expr1), "constraints2"(expr2), ..."</code>. Output
operand expressions must be mutable lvalues, or not yet
assigned:</p>
<pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!("add $2, $0"
             : "=r"(c)
             : "0"(a), "r"(b)
             );
    }
    c
}
# #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
# fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</code></pre>
<p>If you would like to use real operands in this position,
however, you are required to put curly braces <code>{}</code>
around the register that you want, and you are required to put the
specific size of the operand. This is useful for very low level
programming, where which register you use is important:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
# unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!("in %dx, %al" : "={al}"(result) : "{dx}"(port));
result
# }

#}</code></pre>
<h2><a class="header" href="print.html#clobbers" name="clobbers"
id="clobbers">Clobbers</a></h2>
<p>Some instructions modify registers which might otherwise have
held different values so we use the clobbers list to indicate to
the compiler not to assume any values loaded into those registers
will stay valid.</p>
<pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
# fn main() { unsafe {
// Put the value 0x200 in eax:
asm!("mov $$0x200, %eax" : /* no outputs */ : /* no inputs */ : "eax");
# } }
# #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
# fn main() {}
</code></pre>
<p>Input and output registers need not be listed since that
information is already communicated by the given constraints.
Otherwise, any other registers used either implicitly or explicitly
should be listed.</p>
<p>If the assembly changes the condition code register
<code>cc</code> should be specified as one of the clobbers.
Similarly, if the assembly modifies memory, <code>memory</code>
should also be specified.</p>
<h2><a class="header" href="print.html#options" name="options" id=
"options">Options</a></h2>
<p>The last section, <code>options</code> is specific to Rust. The
format is comma separated literal strings (i.e. <code>:"foo",
"bar", "baz"</code>). It's used to specify some extra info about
the inline assembly:</p>
<p>Current valid options are:</p>
<ol>
<li><em>volatile</em> - specifying this is analogous to
<code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
<li><em>alignstack</em> - certain instructions expect the stack to
be aligned a certain way (i.e. SSE) and specifying this indicates
to the compiler to insert its usual stack alignment code</li>
<li><em>intel</em> - use intel syntax instead of the default
AT&amp;T.</li>
</ol>
<pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
# fn main() {
let result: i32;
unsafe {
   asm!("mov eax, 2" : "={eax}"(result) : : : "intel")
}
println!("eax is currently {}", result);
# }
# #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
# fn main() {}
</code></pre>
<h2><a class="header" href="print.html#more-information" name=
"more-information" id="more-information">More Information</a></h2>
<p>The current implementation of the <code>asm!</code> macro is a
direct binding to <a href=
"http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVM's
inline assembler expressions</a>, so be sure to check out <a href=
"http://llvm.org/docs/LangRef.html#inline-assembler-expressions">their
documentation as well</a> for more information about clobbers,
constraints, etc.</p>
<h1><a class="header" href="print.html#associated_consts" name=
"associated_consts" id=
"associated_consts"><code>associated_consts</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29646">#29646</a></p>
<hr>
<p>With the <code>associated_consts</code> feature, you can define
constants like this:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, i32::ID);
}
</code></pre>
<p>Any implementor of <code>Foo</code> will have to define
<code>ID</code>. Without the definition:</p>
<pre><code class=
"language-rust ignore">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
}
</code></pre>
<p>gives</p>
<pre><code class=
"language-text">error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
</code></pre>
<p>A default value can be implemented as well:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32 = 1;
}

impl Foo for i32 {
}

impl Foo for i64 {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, i32::ID);
    assert_eq!(5, i64::ID);
}
</code></pre>
<p>As you can see, when implementing <code>Foo</code>, you can
leave it unimplemented, as with <code>i32</code>. It will then use
the default value. But, as in <code>i64</code>, we can also add our
own definition.</p>
<p>Associated constants don’t have to be associated with a trait.
An <code>impl</code> block for a <code>struct</code> or an
<code>enum</code> works fine too:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#![feature(associated_consts)]

struct Foo;

impl Foo {
    const FOO: u32 = 3;
}

#}</code></pre>
<h1><a class="header" href="print.html#associated_type_defaults"
name="associated_type_defaults" id=
"associated_type_defaults"><code>associated_type_defaults</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29661">#29661</a></p>
<hr>
<h1><a class="header" href="print.html#attr_literals" name=
"attr_literals" id=
"attr_literals"><code>attr_literals</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/34981">#34981</a></p>
<hr>
<h1><a class="header" href="print.html#box_patterns" name=
"box_patterns" id="box_patterns"><code>box_patterns</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29641">#29641</a></p>
<p>See also <a href=
"box-syntax.html"><code>box_syntax</code></a></p>
<hr>
<p>Box patterns let you match on <code>Box&lt;T&gt;</code>s:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(box_patterns)]

fn main() {
    let b = Some(Box::new(5));
    match b {
        Some(box n) if n &lt; 0 =&gt; {
            println!("Box contains negative number {}", n);
        },
        Some(box n) if n &gt;= 0 =&gt; {
            println!("Box contains non-negative number {}", n);
        },
        None =&gt; {
            println!("No box");
        },
        _ =&gt; unreachable!()
    }
}
</code></pre>
<h1><a class="header" href="print.html#box_syntax" name=
"box_syntax" id="box_syntax"><code>box_syntax</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27779">#27779</a></p>
<p>See also <a href=
"box-patterns.html"><code>box_patterns</code></a></p>
<hr>
<p>Currently the only stable way to create a <code>Box</code> is
via the <code>Box::new</code> method. Also it is not possible in
stable Rust to destructure a <code>Box</code> in a match pattern.
The unstable <code>box</code> keyword can be used to create a
<code>Box</code>. An example usage would be:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(box_syntax)]

fn main() {
    let b = box 5;
}
</code></pre>
<h1><a class="header" href="print.html#cfg_target_feature" name=
"cfg_target_feature" id=
"cfg_target_feature"><code>cfg_target_feature</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29717">#29717</a></p>
<hr>
<h1><a class="header" href="print.html#cfg_target_has_atomic" name=
"cfg_target_has_atomic" id=
"cfg_target_has_atomic"><code>cfg_target_has_atomic</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/32976">#32976</a></p>
<hr>
<h1><a class="header" href="print.html#cfg_target_thread_local"
name="cfg_target_thread_local" id=
"cfg_target_thread_local"><code>cfg_target_thread_local</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29594">#29594</a></p>
<hr>
<h1><a class="header" href="print.html#cfg_target_feature" name=
"cfg_target_feature" id=
"cfg_target_feature"><code>cfg_target_feature</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29717">#29717</a></p>
<hr>
<h1><a class="header" href="print.html#compiler_builtins" name=
"compiler_builtins" id=
"compiler_builtins"><code>compiler_builtins</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#concat_idents" name=
"concat_idents" id=
"concat_idents"><code>concat_idents</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29599">#29599</a></p>
<hr>
<p>The <code>concat_idents</code> feature adds a macro for
concatenating multiple identifiers into one identifier.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust">#![feature(concat_idents)]

fn main() {
    fn foobar() -&gt; u32 { 23 }
    let f = concat_idents!(foo, bar);
    assert_eq!(f(), 23);
}
</code></pre>
<h1><a class="header" href="print.html#conservative_impl_trait"
name="conservative_impl_trait" id=
"conservative_impl_trait"><code>conservative_impl_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/34511">#34511</a></p>
<hr>
<p>The <code>conservative_impl_trait</code> feature allows a
conservative form of abstract return types.</p>
<p>Abstract return types allow a function to hide a concrete return
type behind a trait interface similar to trait objects, while still
generating the same statically dispatched code as with concrete
types.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust">#![feature(conservative_impl_trait)]

fn even_iter() -&gt; impl Iterator&lt;Item=u32&gt; {
    (0..).map(|n| n * 2)
}

fn main() {
    let first_four_even_numbers = even_iter().take(4).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(first_four_even_numbers, vec![0, 2, 4, 6]);
}
</code></pre>
<h2><a class="header" href="print.html#background" name=
"background" id="background">Background</a></h2>
<p>In today's Rust, you can write function signatures like:</p>
<pre><code class=
"language-rust ignore">fn consume_iter_static&lt;I: Iterator&lt;Item=u8&gt;&gt;(iter: I) { }

fn consume_iter_dynamic(iter: Box&lt;Iterator&lt;Item=u8&gt;&gt;) { }
</code></pre>
<p>In both cases, the function does not depend on the exact type of
the argument. The type held is "abstract", and is assumed only to
satisfy a trait bound.</p>
<ul>
<li>In the <code>_static</code> version using generics, each use of
the function is specialized to a concrete, statically-known type,
giving static dispatch, inline layout, and other performance
wins.</li>
<li>In the <code>_dynamic</code> version using trait objects, the
concrete argument type is only known at runtime using a
vtable.</li>
</ul>
<p>On the other hand, while you can write:</p>
<pre><code class=
"language-rust ignore">fn produce_iter_dynamic() -&gt; Box&lt;Iterator&lt;Item=u8&gt;&gt; { }
</code></pre>
<p>...but you <em>cannot</em> write something like:</p>
<pre><code class=
"language-rust ignore">fn produce_iter_static() -&gt; Iterator&lt;Item=u8&gt; { }
</code></pre>
<p>That is, in today's Rust, abstract return types can only be
written using trait objects, which can be a significant performance
penalty. This RFC proposes "unboxed abstract types" as a way of
achieving signatures like <code>produce_iter_static</code>. Like
generics, unboxed abstract types guarantee static dispatch and
inline data layout.</p>
<h1><a class="header" href="print.html#const_fn" name="const_fn"
id="const_fn"><code>const_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/24111">#24111</a></p>
<hr>
<p>The <code>const_fn</code> feature allows marking free functions
and inherent methods as <code>const</code>, enabling them to be
called in constants contexts, with constant arguments.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust">#![feature(const_fn)]

const fn double(x: i32) -&gt; i32 {
    x * 2
}

const FIVE: i32 = 5;
const TEN: i32 = double(FIVE);

fn main() {
    assert_eq!(5, FIVE);
    assert_eq!(10, TEN);
}
</code></pre>
<h1><a class="header" href="print.html#const_indexing" name=
"const_indexing" id=
"const_indexing"><code>const_indexing</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29947">#29947</a></p>
<hr>
<p>The <code>const_indexing</code> feature allows the constant
evaluation of index operations on constant arrays and repeat
expressions.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#![feature(const_indexing)]

const ARR: [usize; 5] = [1, 2, 3, 4, 5];
const ARR2: [usize; ARR[1]] = [42, 99];

#}</code></pre>
<h1><a class="header" href="print.html#custom_attribute" name=
"custom_attribute" id=
"custom_attribute"><code>custom_attribute</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29642">#29642</a></p>
<hr>
<h1><a class="header" href="print.html#custom_derive" name=
"custom_derive" id=
"custom_derive"><code>custom_derive</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29644">#29644</a></p>
<hr>
<h1><a class="header" href=
"print.html#default_type_parameter_fallback" name=
"default_type_parameter_fallback" id=
"default_type_parameter_fallback"><code>default_type_parameter_fallback</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27336">#27336</a></p>
<hr>
<h1><a class="header" href="print.html#drop_types_in_const" name=
"drop_types_in_const" id=
"drop_types_in_const"><code>drop_types_in_const</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/33156">#33156</a></p>
<hr>
<h1><a class="header" href="print.html#dropck_eyepatch" name=
"dropck_eyepatch" id=
"dropck_eyepatch"><code>dropck_eyepatch</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/34761">#34761</a></p>
<hr>
<h1><a class="header" href="print.html#dropck_parametricity" name=
"dropck_parametricity" id=
"dropck_parametricity"><code>dropck_parametricity</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/28498">#28498</a></p>
<hr>
<h1><a class="header" href="print.html#exclusive_range_pattern"
name="exclusive_range_pattern" id=
"exclusive_range_pattern"><code>exclusive_range_pattern</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37854">#37854</a></p>
<hr>
<h1><a class="header" href="print.html#field_init_shorthand" name=
"field_init_shorthand" id=
"field_init_shorthand"><code>field_init_shorthand</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37340">#37340</a></p>
<hr>
<h1><a class="header" href="print.html#fundamental" name=
"fundamental" id="fundamental"><code>fundamental</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29635">#29635</a></p>
<hr>
<h1><a class="header" href="print.html#generic_param_attrs" name=
"generic_param_attrs" id=
"generic_param_attrs"><code>generic_param_attrs</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/34761">#34761</a></p>
<hr>
<h1><a class="header" href="print.html#i128_type" name="i128_type"
id="i128_type"><code>i128_type</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/35118">#35118</a></p>
<hr>
<p>The <code>i128_type</code> feature adds support for 128 bit
signed and unsigned integer types.</p>
<pre class="playpen"><code class=
"language-rust">#![feature(i128_type)]

fn main() {
    assert_eq!(1u128 + 1u128, 2u128);
    assert_eq!(u128::min_value(), 0);
    assert_eq!(u128::max_value(), 340282366920938463463374607431768211455);

    assert_eq!(1i128 - 2i128, -1i128);
    assert_eq!(i128::min_value(), -170141183460469231731687303715884105728);
    assert_eq!(i128::max_value(), 170141183460469231731687303715884105727);
}
</code></pre>
<h1><a class="header" href="print.html#inclusive_range_syntax"
name="inclusive_range_syntax" id=
"inclusive_range_syntax"><code>inclusive_range_syntax</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/28237">#28237</a></p>
<hr>
<p>To get a range that goes from 0 to 10 and includes the value 10,
you can write <code>0...10</code>:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(inclusive_range_syntax)]

fn main() {
    for i in 0...10 {
        println!("{}", i);
    }
}
</code></pre>
<h1><a class="header" href="print.html#intrinsics" name=
"intrinsics" id="intrinsics"><code>intrinsics</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<p>Intrinsics are never intended to be stable directly, but
intrinsics are often exported in some sort of stable manner. Prefer
using the stable interfaces to the intrinsic directly when you
can.</p>
<hr>
<p>These are imported as if they were FFI functions, with the
special <code>rust-intrinsic</code> ABI. For example, if one was in
a freestanding context, but wished to be able to
<code>transmute</code> between types, and perform efficient pointer
arithmetic, one would import those functions via a declaration
like</p>
<pre class="playpen"><code class=
"language-rust">#![feature(intrinsics)]
# fn main() {}

extern "rust-intrinsic" {
    fn transmute&lt;T, U&gt;(x: T) -&gt; U;

    fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
}
</code></pre>
<p>As with any other FFI functions, these are always
<code>unsafe</code> to call.</p>
<h1><a class="header" href="print.html#lang_items" name=
"lang_items" id="lang_items"><code>lang_items</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<p>The <code>rustc</code> compiler has certain pluggable
operations, that is, functionality that isn't hard-coded into the
language, but is implemented in libraries, with a special marker to
tell the compiler it exists. The marker is the attribute
<code>#[lang = "..."]</code> and there are various different values
of <code>...</code>, i.e. various different 'lang items'.</p>
<p>For example, <code>Box</code> pointers require two lang items,
one for allocation and one for deallocation. A freestanding program
that uses the <code>Box</code> sugar for dynamic allocations via
<code>malloc</code> and <code>free</code>:</p>
<pre><code class=
"language-rust ignore">#![feature(lang_items, box_syntax, start, libc, core_intrinsics)]
#![no_std]
use core::intrinsics;

extern crate libc;

#[lang = "owned_box"]
pub struct Box&lt;T&gt;(*mut T);

#[lang = "exchange_malloc"]
unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
    let p = libc::malloc(size as libc::size_t) as *mut u8;

    // Check if `malloc` failed:
    if p as usize == 0 {
        intrinsics::abort();
    }

    p
}

#[lang = "exchange_free"]
unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
    libc::free(ptr as *mut libc::c_void)
}

#[lang = "box_free"]
unsafe fn box_free&lt;T: ?Sized&gt;(ptr: *mut T) {
    deallocate(ptr as *mut u8, ::core::mem::size_of_val(&amp;*ptr), ::core::mem::align_of_val(&amp;*ptr));
}

#[start]
fn main(argc: isize, argv: *const *const u8) -&gt; isize {
    let x = box 1;

    0
}

#[lang = "eh_personality"] extern fn rust_eh_personality() {}
#[lang = "panic_fmt"] extern fn rust_begin_panic() -&gt; ! { unsafe { intrinsics::abort() } }
# #[lang = "eh_unwind_resume"] extern fn rust_eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre>
<p>Note the use of <code>abort</code>: the
<code>exchange_malloc</code> lang item is assumed to return a valid
pointer, and so needs to do the check internally.</p>
<p>Other features provided by lang items include:</p>
<ul>
<li>overloadable operators via traits: the traits corresponding to
the <code>==</code>, <code>&lt;</code>, dereferencing
(<code>*</code>) and <code>+</code> (etc.) operators are all marked
with lang items; those specific four are <code>eq</code>,
<code>ord</code>, <code>deref</code>, and <code>add</code>
respectively.</li>
<li>stack unwinding and general failure; the
<code>eh_personality</code>, <code>eh_unwind_resume</code>,
<code>fail</code> and <code>fail_bounds_checks</code> lang
items.</li>
<li>the traits in <code>std::marker</code> used to indicate types
of various kinds; lang items <code>send</code>, <code>sync</code>
and <code>copy</code>.</li>
<li>the marker types and variance indicators found in
<code>std::marker</code>; lang items <code>covariant_type</code>,
<code>contravariant_lifetime</code>, etc.</li>
</ul>
<p>Lang items are loaded lazily by the compiler; e.g. if one never
uses <code>Box</code> then there is no need to define functions for
<code>exchange_malloc</code> and <code>exchange_free</code>.
<code>rustc</code> will emit an error when an item is needed but
not found in the current crate or any that it depends on.</p>
<p>Most lang items are defined by <code>libcore</code>, but if
you're trying to build an executable without the standard library,
you'll run into the need for lang items. The rest of this page
focuses on this use-case, even though lang items are a bit broader
than that.</p>
<h3><a class="header" href="print.html#using-libc" name=
"using-libc" id="using-libc">Using libc</a></h3>
<p>In order to build a <code>#[no_std]</code> executable we will
need libc as a dependency. We can specify this using our
<code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
libc = { version = "0.2.14", default-features = false }
</code></pre>
<p>Note that the default features have been disabled. This is a
critical step - <strong>the default features of libc include the
standard library and so must be disabled.</strong></p>
<h3><a class="header" href=
"print.html#writing-an-executable-without-stdlib" name=
"writing-an-executable-without-stdlib" id=
"writing-an-executable-without-stdlib">Writing an executable
without stdlib</a></h3>
<p>Controlling the entry point is possible in two ways: the
<code>#[start]</code> attribute, or overriding the default shim for
the C <code>main</code> function with your own.</p>
<p>The function marked <code>#[start]</code> is passed the command
line parameters in the same format as C:</p>
<pre><code class=
"language-rust ignore">#![feature(lang_items, core_intrinsics)]
#![feature(start)]
#![no_std]
use core::intrinsics;

// Pull in the system libc library for what crt0.o likely requires.
extern crate libc;

// Entry point for this program.
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = "eh_personality"]
#[no_mangle]
pub extern fn rust_eh_personality() {
}

// This function may be needed based on the compilation target.
#[lang = "eh_unwind_resume"]
#[no_mangle]
pub extern fn rust_eh_unwind_resume() {
}

#[lang = "panic_fmt"]
#[no_mangle]
pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,
                               _file: &amp;'static str,
                               _line: u32) -&gt; ! {
    unsafe { intrinsics::abort() }
}
</code></pre>
<p>To override the compiler-inserted <code>main</code> shim, one
has to disable it with <code>#![no_main]</code> and then create the
appropriate symbol with the correct ABI and the correct name, which
requires overriding the compiler's name mangling too:</p>
<pre><code class=
"language-rust ignore">#![feature(lang_items, core_intrinsics)]
#![feature(start)]
#![no_std]
#![no_main]
use core::intrinsics;

// Pull in the system libc library for what crt0.o likely requires.
extern crate libc;

// Entry point for this program.
#[no_mangle] // ensure that this symbol is called `main` in the output
pub extern fn main(_argc: i32, _argv: *const *const u8) -&gt; i32 {
    0
}

// These functions are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = "eh_personality"]
#[no_mangle]
pub extern fn rust_eh_personality() {
}

// This function may be needed based on the compilation target.
#[lang = "eh_unwind_resume"]
#[no_mangle]
pub extern fn rust_eh_unwind_resume() {
}

#[lang = "panic_fmt"]
#[no_mangle]
pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,
                               _file: &amp;'static str,
                               _line: u32) -&gt; ! {
    unsafe { intrinsics::abort() }
}
</code></pre>
<h2><a class="header" href=
"print.html#more-about-the-language-items" name=
"more-about-the-language-items" id=
"more-about-the-language-items">More about the language
items</a></h2>
<p>The compiler currently makes a few assumptions about symbols
which are available in the executable to call. Normally these
functions are provided by the standard library, but without it you
must define your own. These symbols are called "language items",
and they each have an internal name, and then a signature that an
implementation must conform to.</p>
<p>The first of these functions, <code>rust_eh_personality</code>,
is used by the failure mechanisms of the compiler. This is often
mapped to GCC's personality function (see the <a href=
"https://github.com/rust-lang/rust/blob/master/src/libpanic_unwind/gcc.rs">
libstd implementation</a> for more information), but crates which
do not trigger a panic can be assured that this function is never
called. The language item's name is
<code>eh_personality</code>.</p>
<p>The second function, <code>rust_begin_panic</code>, is also used
by the failure mechanisms of the compiler. When a panic happens,
this controls the message that's displayed on the screen. While the
language item's name is <code>panic_fmt</code>, the symbol name is
<code>rust_begin_panic</code>.</p>
<p>A third function, <code>rust_eh_unwind_resume</code>, is also
needed if the <code>custom_unwind_resume</code> flag is set in the
options of the compilation target. It allows customizing the
process of resuming unwind at the end of the landing pads. The
language item's name is <code>eh_unwind_resume</code>.</p>
<h1><a class="header" href="print.html#link_args" name="link_args"
id="link_args"><code>link_args</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29596">#29596</a></p>
<hr>
<p>You can tell <code>rustc</code> how to customize linking, and
that is via the <code>link_args</code> attribute. This attribute is
applied to <code>extern</code> blocks and specifies raw flags which
need to get passed to the linker when producing an artifact. An
example usage would be:</p>
<pre class="playpen"><code class=
"language-rust no_run">#![feature(link_args)]

#[link_args = "-foo -bar -baz"]
extern {}
# fn main() {}
</code></pre>
<p>Note that this feature is currently hidden behind the
<code>feature(link_args)</code> gate because this is not a
sanctioned way of performing linking. Right now <code>rustc</code>
shells out to the system linker (<code>gcc</code> on most systems,
<code>link.exe</code> on MSVC), so it makes sense to provide extra
command line arguments, but this will not always be the case. In
the future <code>rustc</code> may use LLVM directly to link native
libraries, in which case <code>link_args</code> will have no
meaning. You can achieve the same effect as the
<code>link_args</code> attribute with the <code>-C link-args</code>
argument to <code>rustc</code>.</p>
<p>It is highly recommended to <em>not</em> use this attribute, and
rather use the more formal <code>#[link(...)]</code> attribute on
<code>extern</code> blocks instead.</p>
<h1><a class="header" href="print.html#link_cfg" name="link_cfg"
id="link_cfg"><code>link_cfg</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37406">#37406</a></p>
<hr>
<h1><a class="header" href="print.html#link_llvm_intrinsics" name=
"link_llvm_intrinsics" id=
"link_llvm_intrinsics"><code>link_llvm_intrinsics</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29602">#29602</a></p>
<hr>
<h1><a class="header" href="print.html#linkage" name="linkage" id=
"linkage"><code>linkage</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29603">#29603</a></p>
<hr>
<h1><a class="header" href="print.html#log_syntax" name=
"log_syntax" id="log_syntax"><code>log_syntax</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29598">#29598</a></p>
<hr>
<h1><a class="header" href="print.html#loop_break_value" name=
"loop_break_value" id=
"loop_break_value"><code>loop_break_value</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37339">#37339</a></p>
<hr>
<h1><a class="header" href="print.html#macro_reexport" name=
"macro_reexport" id=
"macro_reexport"><code>macro_reexport</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29638">#29638</a></p>
<hr>
<h1><a class="header" href="print.html#main" name="main" id=
"main"><code>main</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29634">#29634</a></p>
<hr>
<h1><a class="header" href="print.html#naked_functions" name=
"naked_functions" id=
"naked_functions"><code>naked_functions</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/32408">#32408</a></p>
<hr>
<h1><a class="header" href="print.html#needs_allocator" name=
"needs_allocator" id=
"needs_allocator"><code>needs_allocator</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27389">#27389</a></p>
<hr>
<h1><a class="header" href="print.html#needs_panic_runtime" name=
"needs_panic_runtime" id=
"needs_panic_runtime"><code>needs_panic_runtime</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr>
<h1><a class="header" href="print.html#never_type" name=
"never_type" id="never_type"><code>never_type</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/35121">#35121</a></p>
<hr>
<h1><a class="header" href="print.html#no_core" name="no_core" id=
"no_core"><code>no_core</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29639">#29639</a></p>
<hr>
<h1><a class="header" href="print.html#no_debug" name="no_debug"
id="no_debug"><code>no_debug</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29721">#29721</a></p>
<hr>
<h1><a class="header" href="print.html#non_ascii_idents" name=
"non_ascii_idents" id=
"non_ascii_idents"><code>non_ascii_idents</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/28979">#28979</a></p>
<hr>
<p>The <code>non_ascii_idents</code> feature adds support for
non-ASCII identifiers.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#![feature(non_ascii_idents)]

const ε: f64 = 0.00001f64;
const Π: f64 = 3.14f64;

#}</code></pre>
<h1><a class="header" href=
"print.html#omit_gdb_pretty_printer_section" name=
"omit_gdb_pretty_printer_section" id=
"omit_gdb_pretty_printer_section"><code>omit_gdb_pretty_printer_section</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#on_unimplemented" name=
"on_unimplemented" id=
"on_unimplemented"><code>on_unimplemented</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29628">#29628</a></p>
<hr>
<h1><a class="header" href="print.html#optin_builtin_traits" name=
"optin_builtin_traits" id=
"optin_builtin_traits"><code>optin_builtin_traits</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/13231">#13231</a></p>
<hr>
<h1><a class="header" href="print.html#panic_runtime" name=
"panic_runtime" id=
"panic_runtime"><code>panic_runtime</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr>
<h1><a class="header" href="print.html#placement_in_syntax" name=
"placement_in_syntax" id=
"placement_in_syntax"><code>placement_in_syntax</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27779">#27779</a></p>
<hr>
<h1><a class="header" href="print.html#platform_intrinsics" name=
"platform_intrinsics" id=
"platform_intrinsics"><code>platform_intrinsics</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr>
<h1><a class="header" href="print.html#plugin" name="plugin" id=
"plugin"><code>plugin</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29597">#29597</a></p>
<p>This feature is part of "compiler plugins." It will often be
used with the <a href=
"plugin-registrar.html"><code>plugin_registrar</code></a> and
<code>rustc_private</code> features.</p>
<hr>
<p><code>rustc</code> can load compiler plugins, which are
user-provided libraries that extend the compiler's behavior with
new syntax extensions, lint checks, etc.</p>
<p>A plugin is a dynamic library crate with a designated
<em>registrar</em> function that registers extensions with
<code>rustc</code>. Other crates can load these extensions using
the crate attribute <code>#![plugin(...)]</code>. See the
<code>rustc_plugin</code> documentation for more about the
mechanics of defining and loading a plugin.</p>
<p>If present, arguments passed as <code>#![plugin(foo(... args
...))]</code> are not interpreted by rustc itself. They are
provided to the plugin through the <code>Registry</code>'s
<code>args</code> method.</p>
<p>In the vast majority of cases, a plugin should <em>only</em> be
used through <code>#![plugin]</code> and not through an
<code>extern crate</code> item. Linking a plugin would pull in all
of libsyntax and librustc as dependencies of your crate. This is
generally unwanted unless you are building another plugin. The
<code>plugin_as_library</code> lint checks these guidelines.</p>
<p>The usual practice is to put compiler plugins in their own
crate, separate from any <code>macro_rules!</code> macros or
ordinary Rust code meant to be used by consumers of a library.</p>
<h1><a class="header" href="print.html#syntax-extensions" name=
"syntax-extensions" id="syntax-extensions">Syntax
extensions</a></h1>
<p>Plugins can extend Rust's syntax in various ways. One kind of
syntax extension is the procedural macro. These are invoked the
same way as <a href="../book/macros.html">ordinary macros</a>, but
the expansion is performed by arbitrary Rust code that manipulates
syntax trees at compile time.</p>
<p>Let's write a plugin <a href=
"https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs">
<code>roman_numerals.rs</code></a> that implements Roman numeral
integer literals.</p>
<pre><code class="language-rust ignore">#![crate_type="dylib"]
#![feature(plugin_registrar, rustc_private)]

extern crate syntax;
extern crate rustc;
extern crate rustc_plugin;

use syntax::parse::token;
use syntax::tokenstream::TokenTree;
use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
use syntax::ext::build::AstBuilder;  // A trait for expr_usize.
use syntax::ext::quote::rt::Span;
use rustc_plugin::Registry;

fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult + 'static&gt; {

    static NUMERALS: &amp;'static [(&amp;'static str, usize)] = &amp;[
        ("M", 1000), ("CM", 900), ("D", 500), ("CD", 400),
        ("C",  100), ("XC",  90), ("L",  50), ("XL",  40),
        ("X",   10), ("IX",   9), ("V",   5), ("IV",   4),
        ("I",    1)];

    if args.len() != 1 {
        cx.span_err(
            sp,
            &amp;format!("argument should be a single identifier, but got {} arguments", args.len()));
        return DummyResult::any(sp);
    }

    let text = match args[0] {
        TokenTree::Token(_, token::Ident(s)) =&gt; s.to_string(),
        _ =&gt; {
            cx.span_err(sp, "argument should be a single identifier");
            return DummyResult::any(sp);
        }
    };

    let mut text = &amp;*text;
    let mut total = 0;
    while !text.is_empty() {
        match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
            Some(&amp;(rn, val)) =&gt; {
                total += val;
                text = &amp;text[rn.len()..];
            }
            None =&gt; {
                cx.span_err(sp, "invalid Roman numeral");
                return DummyResult::any(sp);
            }
        }
    }

    MacEager::expr(cx.expr_usize(sp, total))
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_macro("rn", expand_rn);
}
</code></pre>
<p>Then we can use <code>rn!()</code> like any other macro:</p>
<pre><code class="language-rust ignore">#![feature(plugin)]
#![plugin(roman_numerals)]

fn main() {
    assert_eq!(rn!(MMXV), 2015);
}
</code></pre>
<p>The advantages over a simple <code>fn(&amp;str) -&gt; u32</code>
are:</p>
<ul>
<li>The (arbitrarily complex) conversion is done at compile
time.</li>
<li>Input validation is also performed at compile time.</li>
<li>It can be extended to allow use in patterns, which effectively
gives a way to define new literal syntax for any data type.</li>
</ul>
<p>In addition to procedural macros, you can define new <a href=
"../reference/attributes.html#derive"><code>derive</code></a>-like
attributes and other kinds of extensions. See
<code>Registry::register_syntax_extension</code> and the
<code>SyntaxExtension</code> enum. For a more involved macro
example, see <a href=
"https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs">
<code>regex_macros</code></a>.</p>
<h2><a class="header" href="print.html#tips-and-tricks" name=
"tips-and-tricks" id="tips-and-tricks">Tips and tricks</a></h2>
<p>Some of the <a href=
"../book/first-edition/macros.html#debugging-macro-code">macro
debugging tips</a> are applicable.</p>
<p>You can use <code>syntax::parse</code> to turn token trees into
higher-level syntax elements like expressions:</p>
<pre><code class=
"language-rust ignore">fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult+'static&gt; {

    let mut parser = cx.new_parser_from_tts(args);

    let expr: P&lt;Expr&gt; = parser.parse_expr();
</code></pre>
<p>Looking through <a href=
"https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs">
<code>libsyntax</code> parser code</a> will give you a feel for how
the parsing infrastructure works.</p>
<p>Keep the <code>Span</code>s of everything you parse, for better
error reporting. You can wrap <code>Spanned</code> around your
custom data structures.</p>
<p>Calling <code>ExtCtxt::span_fatal</code> will immediately abort
compilation. It's better to instead call
<code>ExtCtxt::span_err</code> and return <code>DummyResult</code>
so that the compiler can continue and find further errors.</p>
<p>To print syntax fragments for debugging, you can use
<code>span_note</code> together with
<code>syntax::print::pprust::*_to_string</code>.</p>
<p>The example above produced an integer literal using
<code>AstBuilder::expr_usize</code>. As an alternative to the
<code>AstBuilder</code> trait, <code>libsyntax</code> provides a
set of quasiquote macros. They are undocumented and very rough
around the edges. However, the implementation may be a good
starting point for an improved quasiquote as an ordinary plugin
library.</p>
<h1><a class="header" href="print.html#lint-plugins" name=
"lint-plugins" id="lint-plugins">Lint plugins</a></h1>
<p>Plugins can extend <a href=
"../reference/attributes.html#lint-check-attributes">Rust's lint
infrastructure</a> with additional checks for code style, safety,
etc. Now let's write a plugin <a href=
"https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs">
<code>lint_plugin_test.rs</code></a> that warns about any item
named <code>lintme</code>.</p>
<pre><code class=
"language-rust ignore">#![feature(plugin_registrar)]
#![feature(box_syntax, rustc_private)]

extern crate syntax;

// Load rustc as a plugin to get macros
#[macro_use]
extern crate rustc;
extern crate rustc_plugin;

use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,
                  EarlyLintPassObject, LintArray};
use rustc_plugin::Registry;
use syntax::ast;

declare_lint!(TEST_LINT, Warn, "Warn about items named 'lintme'");

struct Pass;

impl LintPass for Pass {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(TEST_LINT)
    }
}

impl EarlyLintPass for Pass {
    fn check_item(&amp;mut self, cx: &amp;EarlyContext, it: &amp;ast::Item) {
        if it.ident.name.as_str() == "lintme" {
            cx.span_lint(TEST_LINT, it.span, "item is named 'lintme'");
        }
    }
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);
}
</code></pre>
<p>Then code like</p>
<pre><code class=
"language-rust ignore">#![plugin(lint_plugin_test)]

fn lintme() { }
</code></pre>
<p>will produce a compiler warning:</p>
<pre><code class=
"language-txt">foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
</code></pre>
<p>The components of a lint plugin are:</p>
<ul>
<li>
<p>one or more <code>declare_lint!</code> invocations, which define
static <code>Lint</code> structs;</p>
</li>
<li>
<p>a struct holding any state needed by the lint pass (here,
none);</p>
</li>
<li>
<p>a <code>LintPass</code> implementation defining how to check
each syntax element. A single <code>LintPass</code> may call
<code>span_lint</code> for several different <code>Lint</code>s,
but should register them all through the <code>get_lints</code>
method.</p>
</li>
</ul>
<p>Lint passes are syntax traversals, but they run at a late stage
of compilation where type information is available.
<code>rustc</code>'s <a href=
"https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">
built-in lints</a> mostly use the same infrastructure as lint
plugins, and provide examples of how to access type
information.</p>
<p>Lints defined by plugins are controlled by the usual <a href=
"../reference/attributes.html#lint-check-attributes">attributes and
compiler flags</a>, e.g. <code>#[allow(test_lint)]</code> or
<code>-A test-lint</code>. These identifiers are derived from the
first argument to <code>declare_lint!</code>, with appropriate case
and punctuation conversion.</p>
<p>You can run <code>rustc -W help foo.rs</code> to see a list of
lints known to <code>rustc</code>, including those provided by
plugins loaded by <code>foo.rs</code>.</p>
<h1><a class="header" href="print.html#plugin_registrar" name=
"plugin_registrar" id=
"plugin_registrar"><code>plugin_registrar</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29597">#29597</a></p>
<p>This feature is part of "compiler plugins." It will often be
used with the <a href="plugin.html"><code>plugin</code></a> and
<code>rustc_private</code> features as well. For more details, see
their docs.</p>
<hr>
<h1><a class="header" href="print.html#prelude_import" name=
"prelude_import" id=
"prelude_import"><code>prelude_import</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#proc_macro" name=
"proc_macro" id="proc_macro"><code>proc_macro</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/38356">#38356</a></p>
<hr>
<h1><a class="header" href="print.html#quote" name="quote" id=
"quote"><code>quote</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29601">#29601</a></p>
<hr>
<h1><a class="header" href="print.html#relaxed_adts" name=
"relaxed_adts" id="relaxed_adts"><code>relaxed_adts</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/35626">#35626</a></p>
<hr>
<h1><a class="header" href="print.html#repr_simd" name="repr_simd"
id="repr_simd"><code>repr_simd</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr>
<h1><a class="header" href="print.html#rustc_attrs" name=
"rustc_attrs" id="rustc_attrs"><code>rustc_attrs</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29642">#29642</a></p>
<hr>
<h1><a class="header" href="print.html#rustc_diagnostic_macros"
name="rustc_diagnostic_macros" id=
"rustc_diagnostic_macros"><code>rustc_diagnostic_macros</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#rvalue_static_promotion"
name="rvalue_static_promotion" id=
"rvalue_static_promotion"><code>rvalue_static_promotion</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/38865">#38865</a></p>
<hr>
<p>The <code>rvalue_static_promotion</code> feature allows directly
creating <code>'static</code> references to constant
<code>rvalue</code>s, which in particular allowing for more concise
code in the common case in which a <code>'static</code> reference
is all that's needed.</p>
<h2><a class="header" href="print.html#examples" name="examples"
id="examples">Examples</a></h2>
<pre class="playpen"><code class=
"language-rust">#![feature(rvalue_static_promotion)]

fn main() {
    let DEFAULT_VALUE: &amp;'static u32 = &amp;42;
    assert_eq!(*DEFAULT_VALUE, 42);
}
</code></pre>
<h1><a class="header" href="print.html#sanitizer_runtime" name=
"sanitizer_runtime" id=
"sanitizer_runtime"><code>sanitizer_runtime</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#simd" name="simd" id=
"simd"><code>simd</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr>
<h1><a class="header" href="print.html#simd_ffi" name="simd_ffi"
id="simd_ffi"><code>simd_ffi</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr>
<h1><a class="header" href="print.html#slice_patterns" name=
"slice_patterns" id=
"slice_patterns"><code>slice_patterns</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/23121">#23121</a></p>
<p>See also <a href=
"advanced-slice-patterns.html"><code>advanced_slice_patterns</code></a>.</p>
<hr>
<p>If you want to match against a slice or array, you can use
<code>&</code> with the <code>slice_patterns</code> feature:</p>
<pre class="playpen"><code class=
"language-rust">#![feature(slice_patterns)]

fn main() {
    let v = vec!["match_this", "1"];

    match &amp;v[..] {
        &amp;["match_this", second] =&gt; println!("The second element is {}", second),
        _ =&gt; {},
    }
}
</code></pre>
<h1><a class="header" href="print.html#sort_unstable" name=
"sort_unstable" id=
"sort_unstable"><code>sort_unstable</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/40585">#40585</a></p>
<hr>
<p>The default <code>sort</code> method on slices is stable. In
other words, it guarantees that the original order of equal
elements is preserved after sorting. The method has several
undesirable characteristics:</p>
<ol>
<li>It allocates a sizable chunk of memory.</li>
<li>If you don't need stability, it is not as performant as it
could be.</li>
</ol>
<p>An alternative is the new <code>sort_unstable</code> feature,
which includes these methods for sorting slices:</p>
<ol>
<li><code>sort_unstable</code></li>
<li><code>sort_unstable_by</code></li>
<li><code>sort_unstable_by_key</code></li>
</ol>
<p>Unstable sorting is generally faster and makes no allocations.
The majority of real-world sorting needs doesn't require stability,
so these methods can very often come in handy.</p>
<p>Another important difference is that <code>sort</code> lives in
<code>libstd</code> and <code>sort_unstable</code> lives in
<code>libcore</code>. The reason is that the former makes
allocations and the latter doesn't.</p>
<p>A simple example:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#![feature(sort_unstable)]

let mut v = [-5, 4, 1, -3, 2];

v.sort_unstable();
assert!(v == [-5, -3, 1, 2, 4]);

#}</code></pre>
<h1><a class="header" href="print.html#specialization" name=
"specialization" id=
"specialization"><code>specialization</code></a></h1>
<p>The tracking issue for this feature is: [#31844]</p>
<hr>
<h1><a class="header" href="print.html#staged_api" name=
"staged_api" id="staged_api"><code>staged_api</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#start" name="start" id=
"start"><code>start</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29633">#29633</a></p>
<hr>
<h1><a class="header" href="print.html#static_nobundle" name=
"static_nobundle" id=
"static_nobundle"><code>static_nobundle</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37403">#37403</a></p>
<hr>
<h1><a class="header" href="print.html#static_recursion" name=
"static_recursion" id=
"static_recursion"><code>static_recursion</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29719">#29719</a></p>
<hr>
<h1><a class="header" href="print.html#stmt_expr_attributes" name=
"stmt_expr_attributes" id=
"stmt_expr_attributes"><code>stmt_expr_attributes</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/15701">#15701</a></p>
<hr>
<h1><a class="header" href="print.html#struct_field_attributes"
name="struct_field_attributes" id=
"struct_field_attributes"><code>struct_field_attributes</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/38814">#38814</a></p>
<hr>
<h1><a class="header" href="print.html#structural_match" name=
"structural_match" id=
"structural_match"><code>structural_match</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/31434">#31434</a></p>
<hr>
<h1><a class="header" href="print.html#target_feature" name=
"target_feature" id=
"target_feature"><code>target_feature</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#test" name="test" id=
"test"><code>test</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<p>The internals of the <code>test</code> crate are unstable,
behind the <code>test</code> flag. The most widely used part of the
<code>test</code> crate are benchmark tests, which can test the
performance of your code. Let's make our <code>src/lib.rs</code>
look like this (comments elided):</p>
<pre><code class="language-rust ignore">#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
</code></pre>
<p>Note the <code>test</code> feature gate, which enables this
unstable feature.</p>
<p>We've imported the <code>test</code> crate, which contains our
benchmarking support. We have a new function as well, with the
<code>bench</code> attribute. Unlike regular tests, which take no
arguments, benchmark tests take a <code>&amp;mut Bencher</code>.
This <code>Bencher</code> provides an <code>iter</code> method,
which takes a closure. This closure contains the code we'd like to
benchmark.</p>
<p>We can run benchmark tests with <code>cargo bench</code>:</p>
<pre><code class="language-bash">$ cargo bench
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/release/adder-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>Our non-benchmark test was ignored. You may have noticed that
<code>cargo bench</code> takes a bit longer than <code>cargo
test</code>. This is because Rust runs our benchmark a number of
times, and then takes the average. Because we're doing so little
work in this example, we have a <code>1 ns/iter (+/- 0)</code>, but
this would show the variance if there was one.</p>
<p>Advice on writing benchmarks:</p>
<ul>
<li>Move setup code outside the <code>iter</code> loop; only put
the part you want to measure inside</li>
<li>Make the code do "the same thing" on each iteration; do not
accumulate or change state</li>
<li>Make the outer function idempotent too; the benchmark runner is
likely to run it many times</li>
<li>Make the inner <code>iter</code> loop short and fast so
benchmark runs are fast and the calibrator can adjust the
run-length at fine resolution</li>
<li>Make the code in the <code>iter</code> loop do something
simple, to assist in pinpointing performance improvements (or
regressions)</li>
</ul>
<h2><a class="header" href="print.html#gotcha-optimizations" name=
"gotcha-optimizations" id="gotcha-optimizations">Gotcha:
optimizations</a></h2>
<p>There's another tricky part to writing benchmarks: benchmarks
compiled with optimizations activated can be dramatically changed
by the optimizer so that the benchmark is no longer benchmarking
what one expects. For example, the compiler might recognize that
some calculation has no external effects and remove it
entirely.</p>
<pre><code class="language-rust ignore">#![feature(test)]

extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
</code></pre>
<p>gives the following results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>The benchmarking runner offers two ways to avoid this. Either,
the closure that the <code>iter</code> method receives can return
an arbitrary value which forces the optimizer to consider the
result used and ensures it cannot remove the computation entirely.
This could be done for the example above by adjusting the
<code>b.iter</code> call to</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    // Note lack of `;` (could also use an explicit `return`).
    (0..1000).fold(0, |old, new| old ^ new)
});

#}</code></pre>
<p>Or, the other option is to call the generic
<code>test::black_box</code> function, which is an opaque "black
box" to the optimizer and so forces it to consider any argument as
used.</p>
<pre class="playpen"><code class="language-rust">#![feature(test)]

extern crate test;

# fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
# }
</code></pre>
<p>Neither of these read or modify the value, and are very cheap
for small values. Larger values can be passed indirectly to reduce
overhead (e.g. <code>black_box(&amp;huge_struct)</code>).</p>
<p>Performing either of the above changes gives the following
benchmarking results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>However, the optimizer can still modify a testcase in an
undesirable manner even when using either of the above.</p>
<h1><a class="header" href="print.html#thread_local" name=
"thread_local" id="thread_local"><code>thread_local</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29594">#29594</a></p>
<hr>
<h1><a class="header" href="print.html#trace_macros" name=
"trace_macros" id="trace_macros"><code>trace_macros</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29598">#29598</a></p>
<hr>
<h1><a class="header" href="print.html#type_ascription" name=
"type_ascription" id=
"type_ascription"><code>type_ascription</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/23416">#23416</a></p>
<hr>
<h1><a class="header" href="print.html#unboxed_closures" name=
"unboxed_closures" id=
"unboxed_closures"><code>unboxed_closures</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/29625">#29625</a></p>
<hr>
<h1><a class="header" href="print.html#untagged_unions" name=
"untagged_unions" id=
"untagged_unions"><code>untagged_unions</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/32836">#32836</a></p>
<hr>
<h1><a class="header" href="print.html#unwind_attributes" name=
"unwind_attributes" id=
"unwind_attributes"><code>unwind_attributes</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<h1><a class="header" href="print.html#use_extern_macros" name=
"use_extern_macros" id=
"use_extern_macros"><code>use_extern_macros</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/35896">#35896</a></p>
<hr>
<h1><a class="header" href="print.html#windows_subsystem" name=
"windows_subsystem" id=
"windows_subsystem"><code>windows_subsystem</code></a></h1>
<p>The tracking issue for this feature is: <a href=
"https://github.com/rust-lang/rust/issues/37499">#37499</a></p>
<hr></div>
<!-- Mobile navigation buttons --></div>
</div>
<!-- Local fallback for Font Awesome -->
<script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
</script> <!-- Livereload script (if served using the cli tool) -->
 
<script src="highlight.js"></script> 
<script src="book.js"></script>
</body>
</html>
