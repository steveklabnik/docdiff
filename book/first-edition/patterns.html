<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Windows version 5.5.12">
<meta charset="UTF-8">
<title>Patterns - The Rust Programming Language</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="description" content="">
<meta name="viewport" content=
"width=device-width, initial-scale=1">
<base href="">
<link rel="stylesheet" href="book.css">
<link href=
'https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
rel='stylesheet' type='text/css'>
<link rel="shortcut icon" href="favicon.png"><!-- Font Awesome -->
<link rel="stylesheet" href=
"https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<link rel="stylesheet" href="highlight.css">
<link rel="stylesheet" href="tomorrow-night.css"><!-- MathJax -->

<script type="text/javascript" src=
"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- Fetch JQuery from CDN but have a local fallback -->

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
</script>
</head>
<body class="light">
<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
</script> <!-- Hide / unhide sidebar before it is displayed -->
 
<script type="text/javascript">

            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
</script>
<div id="sidebar" class="sidebar">
<ul class="chapter">
<li class="affix"><a href="README.html">Introduction</a></li>
<li><a href="getting-started.html"><strong>1.</strong> Getting
Started</a></li>
<li><a href="guessing-game.html"><strong>2.</strong> Tutorial:
Guessing Game</a></li>
<li><a href="syntax-and-semantics.html"><strong>3.</strong> Syntax
and Semantics</a></li>
<li>
<ul class="section">
<li><a href="variable-bindings.html"><strong>3.1.</strong> Variable
Bindings</a></li>
<li><a href="functions.html"><strong>3.2.</strong>
Functions</a></li>
<li><a href="primitive-types.html"><strong>3.3.</strong> Primitive
Types</a></li>
<li><a href="comments.html"><strong>3.4.</strong> Comments</a></li>
<li><a href="if.html"><strong>3.5.</strong> if</a></li>
<li><a href="loops.html"><strong>3.6.</strong> Loops</a></li>
<li><a href="vectors.html"><strong>3.7.</strong> Vectors</a></li>
<li><a href="ownership.html"><strong>3.8.</strong>
Ownership</a></li>
<li><a href="references-and-borrowing.html"><strong>3.9.</strong>
References and Borrowing</a></li>
<li><a href="lifetimes.html"><strong>3.10.</strong>
Lifetimes</a></li>
<li><a href="mutability.html"><strong>3.11.</strong>
Mutability</a></li>
<li><a href="structs.html"><strong>3.12.</strong> Structs</a></li>
<li><a href="enums.html"><strong>3.13.</strong> Enums</a></li>
<li><a href="match.html"><strong>3.14.</strong> Match</a></li>
<li><a href="patterns.html" class="active"><strong>3.15.</strong>
Patterns</a></li>
<li><a href="method-syntax.html"><strong>3.16.</strong> Method
Syntax</a></li>
<li><a href="strings.html"><strong>3.17.</strong> Strings</a></li>
<li><a href="generics.html"><strong>3.18.</strong>
Generics</a></li>
<li><a href="traits.html"><strong>3.19.</strong> Traits</a></li>
<li><a href="drop.html"><strong>3.20.</strong> Drop</a></li>
<li><a href="if-let.html"><strong>3.21.</strong> if let</a></li>
<li><a href="trait-objects.html"><strong>3.22.</strong> Trait
Objects</a></li>
<li><a href="closures.html"><strong>3.23.</strong>
Closures</a></li>
<li><a href="ufcs.html"><strong>3.24.</strong> Universal Function
Call Syntax</a></li>
<li><a href="crates-and-modules.html"><strong>3.25.</strong> Crates
and Modules</a></li>
<li><a href="const-and-static.html"><strong>3.26.</strong>
<code>const</code> and <code>static</code></a></li>
<li><a href="attributes.html"><strong>3.27.</strong>
Attributes</a></li>
<li><a href="type-aliases.html"><strong>3.28.</strong>
<code>type</code> aliases</a></li>
<li><a href="casting-between-types.html"><strong>3.29.</strong>
Casting between types</a></li>
<li><a href="associated-types.html"><strong>3.30.</strong>
Associated Types</a></li>
<li><a href="unsized-types.html"><strong>3.31.</strong> Unsized
Types</a></li>
<li><a href="operators-and-overloading.html"><strong>3.32.</strong>
Operators and Overloading</a></li>
<li><a href="deref-coercions.html"><strong>3.33.</strong> Deref
coercions</a></li>
<li><a href="macros.html"><strong>3.34.</strong> Macros</a></li>
<li><a href="raw-pointers.html"><strong>3.35.</strong> Raw
Pointers</a></li>
<li><a href="unsafe.html"><strong>3.36.</strong>
<code>unsafe</code></a></li>
</ul>
</li>
<li><a href="effective-rust.html"><strong>4.</strong> Effective
Rust</a></li>
<li>
<ul class="section">
<li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> The
Stack and the Heap</a></li>
<li><a href="testing.html"><strong>4.2.</strong> Testing</a></li>
<li><a href="conditional-compilation.html"><strong>4.3.</strong>
Conditional Compilation</a></li>
<li><a href="documentation.html"><strong>4.4.</strong>
Documentation</a></li>
<li><a href="iterators.html"><strong>4.5.</strong>
Iterators</a></li>
<li><a href="concurrency.html"><strong>4.6.</strong>
Concurrency</a></li>
<li><a href="error-handling.html"><strong>4.7.</strong> Error
Handling</a></li>
<li><a href="choosing-your-guarantees.html"><strong>4.8.</strong>
Choosing your Guarantees</a></li>
<li><a href="ffi.html"><strong>4.9.</strong> FFI</a></li>
<li><a href="borrow-and-asref.html"><strong>4.10.</strong> Borrow
and AsRef</a></li>
<li><a href="release-channels.html"><strong>4.11.</strong> Release
Channels</a></li>
<li><a href=
"using-rust-without-the-standard-library.html"><strong>4.12.</strong>
Using Rust without the standard library</a></li>
<li><a href="procedural-macros.html"><strong>4.13.</strong>
Procedural Macros (and custom derive)</a></li>
</ul>
</li>
<li><a href="glossary.html"><strong>5.</strong> Glossary</a></li>
<li><a href="syntax-index.html"><strong>6.</strong> Syntax
Index</a></li>
<li><a href="bibliography.html"><strong>7.</strong>
Bibliography</a></li>
</ul>
</div>
<div id="page-wrapper" class="page-wrapper">
<div class="page">
<div id="menu-bar" class="menu-bar">
<div class="left-buttons"><i id="sidebar-toggle" class=
"fa fa-bars"></i> <i id="theme-toggle" class=
"fa fa-paint-brush"></i></div>
<h1 class="menu-title">The Rust Programming Language</h1>
<div class="right-buttons"><i id="print-button" class="fa fa-print"
title="Print this book"></i></div>
</div>
<div id="content" class="content">
<h1><a class="header" href="patterns.html#patterns" name="patterns"
id="patterns">Patterns</a></h1>
<p>Patterns are quite common in Rust. We use them in <a href=
"variable-bindings.html">variable bindings</a>, <a href=
"match.html">match expressions</a>, and other places, too. Let’s go
on a whirlwind tour of all of the things patterns can do!</p>
<p>A quick refresher: you can match against literals directly, and
<code>_</code> acts as an ‘any’ case:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}

#}</code></pre>
<p>This prints <code>one</code>.</p>
<p>It's possible to create a binding for the value in the any
case:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    y =&gt; println!("x: {} y: {}", x, y),
}

#}</code></pre>
<p>This prints:</p>
<pre><code class="language-text">x: 1 y: 1
</code></pre>
<p>Note it is an error to have both a catch-all <code>_</code> and
a catch-all binding in the same match block:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    y =&gt; println!("x: {} y: {}", x, y),
    _ =&gt; println!("anything"), // this causes an error as it is unreachable
}

#}</code></pre>
<p>There’s one pitfall with patterns: like anything that introduces
a new binding, they introduce shadowing. For example:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;
let c = 'c';

match c {
    x =&gt; println!("x: {} c: {}", x, c),
}

println!("x: {}", x)

#}</code></pre>
<p>This prints:</p>
<pre><code class="language-text">x: c c: c
x: 1
</code></pre>
<p>In other words, <code>x =&gt;</code> matches the pattern and
introduces a new binding named <code>x</code>. This new binding is
in scope for the match arm and takes on the value of
<code>c</code>. Notice that the value of <code>x</code> outside the
scope of the match has no bearing on the value of <code>x</code>
within it. Because we already have a binding named <code>x</code>,
this new <code>x</code> shadows it.</p>
<h1><a class="header" href="patterns.html#multiple-patterns" name=
"multiple-patterns" id="multiple-patterns">Multiple
patterns</a></h1>
<p>You can match multiple patterns with <code>|</code>:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!("one or two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}

#}</code></pre>
<p>This prints <code>one or two</code>.</p>
<h1><a class="header" href="patterns.html#destructuring" name=
"destructuring" id="destructuring">Destructuring</a></h1>
<p>If you have a compound data type, like a <a href=
"structs.html"><code>struct</code></a>, you can destructure it
inside of a pattern:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!("({},{})", x, y),
}

#}</code></pre>
<p>We can use <code>:</code> to give a value a different name.</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!("({},{})", x1, y1),
}

#}</code></pre>
<p>If we only care about some of the values, we don’t have to give
them all names:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } =&gt; println!("x is {}", x),
}

#}</code></pre>
<p>This prints <code>x is 2</code>.</p>
<p>You can do this kind of match on any member, not only the
first:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { y, .. } =&gt; println!("y is {}", y),
}

#}</code></pre>
<p>This prints <code>y is 3</code>.</p>
<p>This ‘destructuring’ behavior works on any compound data type,
like <a href="primitive-types.html#tuples">tuples</a> or <a href=
"enums.html">enums</a>.</p>
<h1><a class="header" href="patterns.html#ignoring-bindings" name=
"ignoring-bindings" id="ignoring-bindings">Ignoring
bindings</a></h1>
<p>You can use <code>_</code> in a pattern to disregard the type
and value. For example, here’s a <code>match</code> against a
<code>Result&lt;T, E&gt;</code>:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# let some_value: Result&lt;i32, &amp;'static str&gt; = Err("There was an error");
match some_value {
    Ok(value) =&gt; println!("got a value: {}", value),
    Err(_) =&gt; println!("an error occurred"),
}

#}</code></pre>
<p>In the first arm, we bind the value inside the <code>Ok</code>
variant to <code>value</code>. But in the <code>Err</code> arm, we
use <code>_</code> to disregard the specific error, and print a
general error message.</p>
<p><code>_</code> is valid in any pattern that creates a binding.
This can be useful to ignore parts of a larger structure:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn coordinate() -&gt; (i32, i32, i32) {
    // Generate and return some sort of triple tuple.
# (1, 2, 3)
}

let (x, _, z) = coordinate();

#}</code></pre>
<p>Here, we bind the first and last element of the tuple to
<code>x</code> and <code>z</code>, but ignore the middle
element.</p>
<p>It’s worth noting that using <code>_</code> never binds the
value in the first place, which means that the value does not
move:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let tuple: (u32, String) = (5, String::from("five"));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give "error: use of partially moved value: `tuple`".
// println!("Tuple is: {:?}", tuple);

// However,

let tuple = (5, String::from("five"));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!("Tuple is: {:?}", tuple);

#}</code></pre>
<p>This also means that any temporary variables will be dropped at
the end of the statement:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// Here, the String created will be dropped immediately, as it’s not bound:

let _ = String::from("  hello  ").trim();

#}</code></pre>
<p>You can also use <code>..</code> in a pattern to disregard
multiple values:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!("Got a tuple!"),
    OptionalTuple::Missing =&gt; println!("No such luck."),
}

#}</code></pre>
<p>This prints <code>Got a tuple!</code>.</p>
<h1><a class="header" href="patterns.html#ref-and-ref-mut" name=
"ref-and-ref-mut" id="ref-and-ref-mut">ref and ref mut</a></h1>
<p>If you want to get a <a href=
"references-and-borrowing.html">reference</a>, use the
<code>ref</code> keyword:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 5;

match x {
    ref r =&gt; println!("Got a reference to {}", r),
}

#}</code></pre>
<p>This prints <code>Got a reference to 5</code>.</p>
<p>Here, the <code>r</code> inside the <code>match</code> has the
type <code>&amp;i32</code>. In other words, the <code>ref</code>
keyword <em>creates</em> a reference, for use in the pattern. If
you need a mutable reference, <code>ref mut</code> will work in the
same way:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut x = 5;

match x {
    ref mut mr =&gt; println!("Got a mutable reference to {}", mr),
}

#}</code></pre>
<h1><a class="header" href="patterns.html#ranges" name="ranges" id=
"ranges">Ranges</a></h1>
<p>You can match a range of values with <code>...</code>:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 ... 5 =&gt; println!("one through five"),
    _ =&gt; println!("anything"),
}

#}</code></pre>
<p>This prints <code>one through five</code>.</p>
<p>Ranges are mostly used with integers and <code>char</code>s:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = '💅';

match x {
    'a' ... 'j' =&gt; println!("early letter"),
    'k' ... 'z' =&gt; println!("late letter"),
    _ =&gt; println!("something else"),
}

#}</code></pre>
<p>This prints <code>something else</code>.</p>
<h1><a class="header" href="patterns.html#bindings" name="bindings"
id="bindings">Bindings</a></h1>
<p>You can bind values to names with <code>@</code>:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!("got a range element {}", e),
    _ =&gt; println!("anything"),
}

#}</code></pre>
<p>This prints <code>got a range element 1</code>. This is useful
when you want to do a complicated match of part of a data
structure:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = "Steve".to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!("{:?}", a),
    _ =&gt; {}
}

#}</code></pre>
<p>This prints <code>Some("Steve")</code>: we’ve bound the inner
<code>name</code> to <code>a</code>.</p>
<p>If you use <code>@</code> with <code>|</code>, you need to make
sure the name is bound in each part of the pattern:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!("got a range element {}", e),
    _ =&gt; println!("anything"),
}

#}</code></pre>
<h1><a class="header" href="patterns.html#guards" name="guards" id=
"guards">Guards</a></h1>
<p>You can introduce ‘match guards’ with <code>if</code>:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!("Got an int bigger than five!"),
    OptionalInt::Value(..) =&gt; println!("Got an int!"),
    OptionalInt::Missing =&gt; println!("No such luck."),
}

#}</code></pre>
<p>This prints <code>Got an int!</code>.</p>
<p>If you’re using <code>if</code> with multiple patterns, the
<code>if</code> applies to both sides:</p>
<pre class="playpen"><code class=
"language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!("yes"),
    _ =&gt; println!("no"),
}

#}</code></pre>
<p>This prints <code>no</code>, because the <code>if</code> applies
to the whole of <code>4 | 5</code>, and not to only the
<code>5</code>. In other words, the precedence of <code>if</code>
behaves like this:</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>not this:</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h1><a class="header" href="patterns.html#mix-and-match" name=
"mix-and-match" id="mix-and-match">Mix and Match</a></h1>
<p>Whew! That’s a lot of different ways to match things, and they
can all be mixed and matched, depending on what you’re doing:</p>
<pre><code class="language-rust ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>Patterns are very powerful. Make good use of them.</p>
</div>
<!-- Mobile navigation buttons -->
 <a href="match.html" class="mobile-nav-chapters previous"></a>
<a href="method-syntax.html" class=
"mobile-nav-chapters next"></a></div>
<a href="match.html" class="nav-chapters previous" title=
"You can navigate through the chapters using the arrow keys"></a>
<a href="method-syntax.html" class="nav-chapters next" title=
"You can navigate through the chapters using the arrow keys"></a></div>
<!-- Local fallback for Font Awesome -->
<script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
</script> <!-- Livereload script (if served using the cli tool) -->
 
<script src="highlight.js"></script> 
<script src="book.js"></script>
</body>
</html>
